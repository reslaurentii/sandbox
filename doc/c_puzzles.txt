                               THE                                                •
                                                                                     in5                   THE                ,'*
                                                                                     e
                                                                                     a
                                                                                      [
                                                                                       •
                              ALAHRFEUER                                               ..-
                                                                                       COl
                                                                                       a'
                                                                                      i'
. . of II8rning C may be modeled by three steps:
IerItand the language syntax;
                                                                                       ..
                                                                                       n
                                                                                       -a
                                                                                       0
                                                                                      CI
                                                                                       Dl
IW what meaning the translator will ascribe to properly formed constructions;          a
                                                                                       i.
'fIGp. programming style fitting for the language.
lei in this book are designed to hefp the reader through step two. They will
I the reeder's mastery of the basic rules of C and lead the reader into seldom-
:omens, beyond reasonable limits, and past a few open pits. In short, they
                                                                                      -
                                                                                      S
                                                                                     CI
                                                                                       Q)
                                                                                      :I
                                                                                      I:
                                                                                     'i
                                                                                       Q)
,. r ' " with insight into C that is usually only gained through considerable
Ie.
IUIe Book    is a workbook intended to be used with a C language textbook. The         "TI
ivided into sections, each containing C programs that explore a particular aspect      m
ompanying detailed descriptions of how the programs work are tips and caveats          c
~  allcceeslul C programs.                                                             m
                                                                                       ]I
Iaook of Int.r••t ...
ogramming Language by Brian W. Kemighan and Dennis M. Ritchie is the
 l8X1book on the C language. h includes a tutorial introduction to C giving a
~ to most of the language; it incorporates complete programs as
5; it deecribes the standard 1/0 library showing how to write programs that can
I bIlwefnc:omputer systems; and it illustrates how to interface with the UNIX
~~.
                                                                         226p.
                                                                                           P117~les lor the CProgramming Langu
                                                                                    (J 1.0               ALAN R. FEUER
                                                                                    OSB
PRENTICE-HALL SOFTWARE SERIES    THE C PUZZLE BOOK
     Brian W. Kernighan, advisor
                                         Alan R. Feuer
                                            Bell Laboratories
                                         Murray Hill, New Jersey 637.0
                                                                  DSS
                                    PRENTICE-HALL, INC.,
                                   Englewood Cliffs, NJ 07632
L_.]Y of Congress Cataloging In PubUcation Data
Feuer. Alan.
    The C puzzle book.
                                                                                                            CONTENTS
    (Prentice.Han software series)
     Includes index.
     1. C (Computer program language)          2. UNIX (Computer
system)      l. Title.    II. Series.
QA76.73.CI5F48            001.64'24        82-5302                Preface .......................................................................................... page vii
ISBN 0_13_109934-5                         AACR2
ISBN 0-13-109926-4 (pbk.)
                                                                 PUZZLES
 Edilorial/produCiion supervision: Nancy Milnamo w                Operators ................................. . ....................................................... page I
 Cover design: Ray Lundgren
 Manufacturing burn: Gordon Osbourne                                 1.  Basic Arithmetic Operators 3
                                                                     2.  Assignment Operators 5
                                                                     3.  Logic and Increment Operators 7
 © 1982 by Bell Laboratories. Incorporated
                                                                     4.  Bitwise Operators 9
  All rights reserved. No part of this book                          5. Relational and Conditional Operators II
  may be reproduced in any form or
                                                                     6.  Operator Precedence and Evaluation 13
  by any means without permission in writing
  from the publisher.                                             Basic Types.......... ............... ....... .................................................... page 15
  Printed in the United States of America                            I.  Character, String, and Integer Types 17
                                                                     2.  Integer and Floating Point Casts 19
   10 9 8 7 6 5 4
                                                                     3.  More Casts 21
                                                                  Included Files ............................. .. ................................................. page 23
                                                                  Control Flow .......................... ....................................................... page 25
                                                                     I.  if Statement 27
                                                                     2.  while and for Statements 29
                                                                     3.  Statement Nesting 31
                                                                     4.  switch. break, and continue Statements 33
    ISBN 0-13-109934-5                                            Programming Style ........................................................................ page 35
    ISBN 0-13-109926-4 {pbk.}
                                                                     I.  Choose the Right Condition 37
                                                                     2.  Choose the Right Construct 39
                                                                  Storage Classes........ ............... ......................................................
                                                                                                              .                                                      page 4 I
                                                                     1.  Blocks 43
                                                                     2.  Functions 45
     Prentice-Hall International. Inc .. London
      Prentice-Hall of Australia Pty. Limited. Sydney                3.  More Functions 47
      Prentice-Hall of Canada. Ltd., Toronto                         4.  Files 49
      Prentice-Hall of India Private Limited. New Delhi
      Prentice-Hall of Japan. Inc., Tokyo
      Prentice-Hall of Southeast Asia pte. Ltd .• Singapore
      Whitehall Books Limited. Wellington. New Zealand
                                                                                                                                                            PREFACE
nters and Arrays ......................................... ·········· .................... page 51
 . Simple Pointer and Array 53
                                                                                                                 C is not a large language. Measured by the weight of its reference manual, C could even
 .    Array of Pointers 55                                                                                       classified as small. The small size reflects a lack of confining rules rather than a lack of PO\\
                                                                                                                 Users of C learn early to appreciate the elegance of expression afforded by its clear design.
3. Multidimensional Array 57
4. Pointer Stew 59                                                                                               Such elegance might seem needlessly arcane for new C programmers. The lack of restricti(
                                                                             ....................... page 61     means that C programs can be and are written with full-bodied expressions that may appear
 uc:tures ............ ··································· ............... .
                                                                                                                 printing errors to the novice. The cohesiveness of C often admits clear, but terse, ways
1. Simple Structure, Nested Structure 63                                                                         express common programming tasks.
2.    Array of Structures 65
                                                                                                                 The process of learning C, as for any programming language, may be modeled by three stt
3.    Array of Pointers to Structures 67                                                                         (no doubt repeated many times over). Step one is to understand the language syntax, at Ie
cprocessor .................................................. ................................ page 69           to the point where the translator no longer complains of meaningless constructions. Step twe
                                                                                                                 to know what meaning the translator will ascribe to properly formed constructions. And st
 1. The Preprocessor Doesn't Know C 71                                                                           three is to develop a programming style fitting for the language; it is the art of writing cle,
                                                                                                                 concise, and correct programs.
 2. Caution Pays 73
                                                                                                                 The puzzles in this book afe designed to help the reader through the second step. They \\
                                                                                                                 challenge the reader's mastery of the basic rules of C and lead the reader into seldom reach
 UTIONS                                                                                                          corners, beyond reasonable limits, and past a few open pits. (Yes, C, as all real languages, l-
                                                                                                                 its share of obscurities that are learned by experience.)
 )perators ....................................................................................... page 77
     . T                                                                   ............................. page 97 The puzzles should not be read as samples of good coding; indeed, some of the code
 kislC ypes ................. ······· .. ·· .. ······················ .. .
                                                                                                                 atrocious. But this is to be expected. Often the same qualities that make a program poor ma
 ~ontrol Flow .................................................. ·.......... ·........ ·· ...... ·page 105       a puzzle interesting:
 trogramming Style ............................................. ·· .............. ·· .... · .. page 117                • ambiguity of expression, requiring a rule book to interpret;
    .
 itorage   Classes ............................................... ............................. page 123               • complexity of structure, data and program structure not easily kept in one's head;
 'ointers and A       rrays ................. · ........................ ·· ......................... page 129          • obscurity of usage, using concepts in nonstandard ways.
 ,
 ,tructures    ................................. .. ................................................. page 141   C is still an evolving language. Depending upon the vintage of your local compiler, some
 ~reprocessor      ................................................... . ............................ page 158   the features explored here may not be implemented and some of the implemented features m.
                                                                                                                 not be explored here. Fortunately, the evolution of C has proceeded uniformly, so it is ve
                                                                                                                 unlikely that your compiler will have a feature implemented in a different way than describt
  'ENDlCFS                                                                                                       here.
  1. P reced ence Ta bl e ......................................... .. ........................ page 165
  2.  Operator Summary Table .......................... ·· .......................... ·page 167                  HOW TO USE THIS BOOK
  3. ASCII Table ........................................................................... page 171
                                                                                                                 The C Puzzle Book is a workbook intended to be used with a C language textbook such as The
  4. Type erarc Y a .......................................... ................... page 173
              Hi          h Ch rt                                                                                Programming Language by Brian Kernighan and Dennis Ritchie (Prentice-Hall, 1978). Th
                                                                                                                 book is divided into sections with one major topic per section. Each section comprises
                                                                                                                 programs that explore different aspects of the section topic. The programs are sprinkled wit
                                                                                                                 print statements. The primary task is to discover what each program prints. All of tb
viii PREFACE
programs are independent of one another, though the later puzzles assume that you understand
the properties of C illustrated in earlier puzzles.
The output for each program is given on the page following the text of the program. Each of
the programs was run from the text under the UNIXt Operating System on Digital Equipment
Corporation PDP 11/70 and VAX 11/780 computers. For the few cases where the output is
different on the two machines, output is given from both.
The larger portion of the book is devoted to step-by-step derivations of the puzzle solutions.
Many of the derivations are accompanied by tips and caveats for programming in C.              THE C PUZZLE BOOK
A typical scenario for using the puzzles might go like this:
      • Read about a topic in the language textbook .
      • For each program in the puzzle book section on the topic
             -  Work the puzzles of the program.
             -  Compare your answers to the program output.
             -  Read the solution derivations.
ACKNOWLEDGEMENTS
The first C puzzles were developed for an introductory C programming course that I taught at
Bell Laboratories. The encouraging response from students led me to hone the puzzles and
embellish the solutions. A number of my friends and colleagues have given valuable
comments and corrections to various drafts of this book. They are Al Boysen, Jr., Jeannette
Feuer, Brian Kernighan, John Linderman, David Nowitz, Elaine Piskorik, Bill Roome, Keith
Vollherbst, and Charles Wetherell. Finally, I am grateful for the fruitful environment and
generous support provided me by Bell Laboratories.
                                                                              Alan Feuer
t UNIX is a trademark of Dell Laboratories.
PUZZLES                                Operators
                    1.  Basic Arithmetic Operators
                    2. Assignment Operators
                    3. Logic and Increment Operators
                    4.  Bitwise Operators
                    5.  Relational and Conditional Operators
                    6. Operator Precedence and Evaluation
C programs are built from statements, statements from expressions, and
expressions from operators and operands. C is unusually rich in operators; see
the operator summary of Appendix 2 if you need convincing. Because of this
richness, the rules that determine how operators apply to operands play a
central role in the understanding of expressions. The rules, known as
precedence and associativity, are summarized in the precedence table of
Appendix 1. Use the table to solve the problems in this section.
                                                                PUZZLnS 3
                        Operators 1: Basic Arithmetic Operators
What does the following program print?
  main ( )
  {
         int Xj
        x  =  -  3 +  4
                         * 5  - 6j printf("%d\n",x)j         (Operators J. J)
        x  = 3 + 4    % 5 - 6j printf("%d\n",x)j             (Operators J. 2)
        x  = - 3 *    4 % - 6 / 5 j printf("%d\n",x)j        (Operators J. 3)
        x  =     7 +  6 ) % 5 / 2j printf("%d\n",x)j         (Operators J. 4 )
  }
                                                                                                                        PUZZLES
 PUZZLES
                   Operators 1: Basic Arithmetic Operators                            Operators 2: Assignment Operators
                                                           What does the following program print?
IUTPUT:
                                                             #define PRINTX printf("%d\n",x)
   11            (Operators 1.1)
   1             (Operators 1.2)
                                                             main ( )
   o             (Operators 1.3)
   1             (Operators 1.4)
                                                                    int x=2, y, Z;
                                                                   x *= 3     + 2; PRINTX;           (Operators 2. J)
~rivations begin on page 77.                                       x *= y = Z = 4; PRINTX;           (Operators 2.2)
                                                                   x = y == Z; PRINTX;               (Operators 2.3)
                                                                   x == ( y = Z ); PRINTX;           (Operators 2.4)
                                                                                                                          PUZZLES 7
 PUZZLES
                       Operators 2: Assignment Operators                        Operators 3: Logic and Increment Operators
                                                         What does the following program print?
ffTPUT:
                                                           #define PRINT(int) printf("%d\n",int)
  10             (Operators 2.1)
  40             (Operators 2.2)
                                                           main( )
                 (Operators 2.3)
  1              (Operators 2.4)
                                                                 int x, y, Z;
                                                                 x = 2 ; Y = 1 ,• z = o·,
                                                                                 ,,
                                                                 x = x &.&. Y , , Z; PRINT(x) ;
,rivations begin on page 80.                                                                                        (Operators 3.1 )
                                                                 PRINT( x I' II     Y &.&. Z ) ;                    (Operators 3.2)
                                                                 x  =y =     1;
                                                                 z = x ++ - 1; PRINT(x); PRINT(z);                  (Operators 3.3)
                                                                 z += - x ++ + ++ y; PRINT(x); PRINT(z);           (Operators 3.4)
                                                                 z = x / ++ x; PRINT(z);                           (Operators 3.5)
 PUZZLFS                                                                                                                     PUZZLFS S
                  Operators 3: Logic and Increment Operators                                  Operators 4: Bitwise Operators
UTPUT:                                                          What does the following program print?
   1              (Operators 3.1)                                 #define PRINT(int) printf("int = %d'n",int)
   1              (Operators 3.1)
  2               (Operators 3.3)                                 maine )
                                                                  {
  0
   3              (Operators 3.4)                                       int x, y, Z;
   0
   ?              (Operators 3.5)                                       x = 03; Y      = 02;  Z   = 01;
                                                                        PRINT(     x    y & Z );         (Operators 4.1)
                                                                        PRINT(     x    Y & -   Z  );    (Operators 4.1)
                                                                        PRINT(     x    y & - Z );       (Operators 4.3)
terlvalions begin on page 83.                                           PRINT(     x &  y && Z );        (Operators 4.4)
                                                                        x = 1 ; Y = -1 ;
                                                             f.         PRINT( I x        x ) ;          (Operators 4.5)
                                                                        PRINT(     -    I
                                                                                     x I X );            (Operators 4.6)
                                                                        PRINT( x     A
                                                                                        x );             (Operators 4.7)
                                                                        X «= 3 ; PRINT (x) ;             (Operators 4.8)
                                                                        y «= 3 ; PRINT(y) ;              (Operators 4.9)
                                                                        y »= 3 ; PRINT(y) ;             (Operators 4.10)
                            Operators 4: Bitwise Operators            Operators 5: Relational and Conditional Ooerators
OUTPUT:                                                    What does the following program print?
     x II   y & z      = 3         (Operators 4.1)           'define PRINT(int) printf("int = %d'n",int)
     x II   Y &   -  z       3     (Operators 4.2)
     x      y &   -  z    =        (Operators 4.3)           main ( )
     x &    y && z = 1             (Operators 4.4)           {
            I
     I x    I  x                   (Operators 4.5)                  int x=1, y=1, z=1;
     -  x   I
            I  X    = -1           (Operators 4.6)
     x      x = 0                  (Operators 4.7)                  x += y += z;
   x = 8                           (Operators 4.8)                  PRINT( x < y ? y : x );                (Operators 5.1)
   y = -8                          (Operators 4.9)
   y      ?                       (Operators 4.10)                  PRINT( x < y ? x ++ : y ++ );
                                                                    PRINT(x); PRINT(y);                    (Operators 5.2)
                                                                    PRINT( z += x < Y ? x ++      y ++ );
Derivations begin on page 86.
                                                                    PRINT(y); PRINT(z);                    (Operators 5.3)
                                                                    x-3; y-z-4;
                                                                    PRINT( (z >- y >- x) ? 1: 0);          (Operators 5.4)
                                                                    PRINT( z >- y && Y >- x );             (Operators 5.5)
             Operators 5: Relational and Conditional Operators                       Operators 6: Operator Precedence and Evaluation
OUTPUT:                                                        What does the following program print?
     x < Y ? Y : x = 3                      (Operators 5.1)      'define PRINT3(x,y,z)           printf("x=~d'ty=~d'tz=~d'n",x,y,z)
     x < Y ? x ++ : y ++             = 2    (Operators 5.2)
   x = 3                                                         maine )
   Y .. 3                                                        {
     z += x < y ? x ++             y  ++ 4  (Operators 5.3)            int x, y, Z;
   y = 4
   z = 4                                                               x = y = z         .  1;
     (z   >= Y >= x)       ?   1   0110     (Operators 5.4)                   I I
                                                                        ++x I I      ++y   && ++z; PRINT3(x,y,z);    (Operators 6.1)
     Z >= Y     &&   y >=    x   = 1        (Operators 5.5)
                                                                        x  . Y = z = 1;
                                                                        ++x && ++y II II ++z; PRINT3(x,y,z);         (Operators 6.2)
Derivations begin on page 91.
                                                                        x = Y = z = 1;
                                                                        ++x && ++y && ++z; PRINT3(x,y,z);            (Operators 6.3)
                                                                        x = y     ..  z '" -1 ;
                                                                        ++x && ++y II II ++z; PRINT3(x,y,z);         (Operators 6.4)
                                                                        x = Y = z = -1 ;
                                                                        ++x "I I ++y && ++z; PRINT3(x,y,z);          (Operators 6.5)
                                                                        x = Y = z = -1 ;
                                                                        ++x && ++y && ++z; PRINT3(x,y,z);            (Operators 6.6)
               Operators 6: Operator Precedence dEvaluation
                                                                                 1. Character, String, and Integer Types
OUTPUT:                                                                          2.  Integral and Floating Point Casts
                                                                                 3.  More Casts
   x=2      y=1      z=1      (Operators 6.1 )
   x=2      y=2      z .. 1   (Operators 6.2)
   x=2      y=2      z=2      (Operators 6.3)
   x-o      y=-1 z=o          (Operators 6.4)
   x=o      y=o      z=-1     (Operators 6.5)
   x=o      y=-1 z=-1         (Operators 6.6)
Derivations begin on page 94.
                                                            C has a comparatively small set of primitive types. The types may blindly be
                                                            mixed in expressions, the results governed by a simple hierarchy of
                                                            conversions. This hierarchy is illustrated in Appendix 4.
                                                            For some of the puzzles in this section you will need to know the
                                                            corresponding integer value of some characters. The tables in Appendix 3
                                                            show the values for the characters in the ASCII set. A few of the puzzles yield
                                                            a different result on the VAX than on the PDP 11. For those puzzles, output
                                                            from both machines is given.
                                                                                                            15
                                                                 _ JZZLES 17
             Basic Types 1: Character, String, and Integer Types
   What does the following program print?
     #include <stdio.h>
     #define PRINT(format,x) printf("x = %format'n" ,x)
     int integer = 5;
     char character = '5';
     char *string = "5";
     maine )
     {
           PRINT(d,string); PRINT(d,character); PRINT(d,integer);
           PRINT(s,string); PRINT(c,character); PRINT(c,integer=53);
           PRINT(d,( '5'>5»;                                 (Basic Types 1.1)
f
f.
                  int sx = -8;
                  unsigned ux = -8;
                  PRINT(o,sx); PRINT(o,ux);
                  PRINT(o, sx»3 ); PRINT(o, ux»3 );
                  PRINT(d, ax»3 ); PRINT(d, ux»3 );          (Basic Types 1.2)
18 PUZZLI                                                                                                                             PUZZLF1
             Basic Types 1: Character, String, and Integer Types                  Basic Types 2: Integer and Floating Point Casts
OUTPUT:                                                               What does the following program print?
   string = an address                              (Basic Types 1.1)   'include <atdio.h>
   character = 53
   integer = 5                                                          'define PRIx) printf("x = X.8g\t",(double)x)
   string = 5                                                           'define NL putchar('\n')
    character = 5                                                       'define PRINT4(x1,x2,x3,x4)          PR(x1); PR(x2); PR(x3); PR(x4)
    integer=53 = 5
    ( '5'>5 ) = 1                                                       main( )
                                            (Basic Types I.2-PDP 11)    {
   sx = 177770
   ux = 177770                                                                double d;
      sx»3 = 177777 or 017777                                                 float f;
      ux»3 = 17777                                                            long 1;
      ax»3 = -1 M 8191                                                        int i;
      ux»3 = 8191
                                                                              i = 1 = f =d =        100/3; PRINT4(i,l,f,d);        (Basic Typej l.1
    sx = 37777777770                           (Basic Types 1.2-VAX)          d = f = 1 = i =       100/3; PRINT4(i,1,f,d);        (Basic Typej t.z
    ux = 37777777770                                                          i = 1 = f = d =       100/3:.; PRINT4(i,1,f,d);      (Basic Typej i'.)
      sx»3 = 37777777777 or 03777777777                                       d = f = 1        i =  (double)100/3;
      ux»3 = 3777777777                                                       PRINT4(i,1,f,d);                                     (Basic Typej <4
      ax»3 = -1 or 536870911
      ux»3 = 536870911
                                                                              i = 1 = f = d = (double)(100000/3l;
                                                                              PRINT4(i,1,f,d);                                     (Basic Typej ~. '7
 Derivations begin on page 97.
                                                                              d = f = 1 = i = 100000/3; PRINT4(i,1,f,d);
                                                                                                                                                        PUZZLE
20 PUZZLES
                Basic Types 2: Integer and Floating Point Casts                                                         Basic Types 3: More Casts
                                                                                              What does the following program print?
OUTPUT:
                                                                      (Basic Types 2.1)         #include <stdio.h>
   i  ..  33          33    f  .. 33  d .. 33                                            Ii
                1 -                                                   (Basic Types 2.2)   ~
   i  ..  33 1 -                  33  d .. 33
                      33    f  •                                      (Basic Types 2.3)  ft     #define    PR(x) printf("x = %g\t",(double)(x»
   i  ..  33 1 ..     33          33.333332 d .. 33.333333
                            f •                                       (Basic Types 2.4)   ~     #define   NL putchar('\n')
   i  •   33 1 ..     33    f .. 33   d .. 33                                             ~.
                                                                                                #define    PRINT1(x1)      PR(x1); NL
                                      f • 33333   d .. 33333  (Basic Types 2.5·PDP 11)   k"
   i •    overflow    1 .. 33333                                                                'define   PRINT2(x1,x2) PR(x1); PRINT1(x2)
                                                  d .. -32203 (Basic Types 2.6·PDP 11)    ~',
    i ..  overflow    1 .. -32203     f .. -32203
                                                                                         J
                                         .                                                      maine )
    i .. 33333
    i .. 33333
                       1 .. 33333
                       1 .. 33333
                                       f
                                       f
                                           33333
                                         • 33333
                                                  d .. 33333
                                                  d .. 33333
                                                                 (Basic Types 2.5·YAX)
                                                                 (Basic Types 2.6·YAX)
                                                                                        If~
                                                                                                {
                                                                                                      double d=3.2, X;
                                                                                                      int i=2, y;
                                                                                         i
                                                                                                      X = (y-d/i)*2; PRINT2(x,y);                   (Basic TypeJ
 Derivations begin on page 99.
                                                                                                      y - (x=d/i)*2; PRINT2(x,y);                   (Basic TypeJ
                                                                                                      y     d * (x=2.5/d); PRINT1(y);               (Basic Typej
                                                                                                      x     d * (y = «int)2.9+1.1)/d); PRINT2(x,y); (Basic Typej
22 PUZZLES
                                                                                             Included Files
                              Basic Types 3: More Casts
                                                         Each of the remaining programs in this book begins with the preprocessor statement
                                                             linclude "defs.h"
                                                         When the programs are compiled, the preprocessor replaces this line with the contents of the
OUTPUT:                                                  file defs.h, making the definitions in defs.h available for use. Here is a listing of
                                                         defs.h:
   x = 2          Y =   1       (Basic Types 3.1)
                                                             linclude <stdio.h>
                                (Basic Types 3.2)
   x •
           1.6    Y = 3
                                (Basic Types 3.3)            Idefine PR(format,value) printf("value •                   ~format\t",(value»
   Y .. 2
                                (Basic Types 3.4)
                                                             Idefine NL putchar('\n')
    x = 0         y   = 0
                                                             Idefine PRINT1(f,x1) PR(f,x1), NL
                                                             Idefine PRINT2(f,x1~x2) PR(f,x1), PRINT1(f,x2)
                                                             Idefine PRINT3(f,x1,x2,x3) PR(f,x1), PRINT2(f,x2,x3)
 Derivations begin on page 103.                              Idefine PRINT4(f,x1,x2,x3,x4)               PR(f,x1), PRINT3(f,x2,x3,x4)
                                                         def8.h begins with an include statement of its own, calling for the insertion of the file
                                                         .tdio.h, as required by the standard C library. The rest of defs.h comprises macros for
                                                         printing. As an example, to print 5 as a decimal number, the PRINT1 macro could be called
                                                        by the expression
                                                             PRINT 1 ( d , 5 )
                                                        which expands to
                                                             PR(d, 5), NL
                                                        which further expands to
                                                             printf("S ..      ~d\t·,(S»,      putchar('\n').
                                                        The PRINT macros point out a feature of the preprocessor that often causes confusion. A
                                                        IIICrO name that appears inside a string (Le., enclosed within double quotes) will not be
                                                        expanded. However, argument names within the body of a macro will be replaced wherever
                                                        they are found, even inside strings. Notice that the macro PR takes advantage of the latter
                                                        property. See the Preprocessor Section, beginning on page 69, for a more detailed description
                                                        of macro substitution.
                                                                                                      23
                               Control Flow
                1.   if Statement
                2.   while and for Statements
                3. Statement Nesting
                4.   swi tch, break, and continue Statements
C, as most programming languages, has control constructs for conditional
selection and looping. To work the puzzles in this section, you will need to
know how to determine the extent of each construct. In a well-formatted
program, extent is indicated by indentation. Reading a poorly-formatted
program is difficult and error prone; the following puzzles should convince you.
                                                 25
                                                           PUZZLI 7
                       Control Flow 1: if Statement
What does the following program print?
  #include "defs.h"
  maine )
  {
         int x, y= 1, z;
         if( yl=O ) x=5;
        PRINT1 (d,x);                   (Control Flow 1.1)
        if( y==O ) x=3;
        else x=5;
        PRINT1 (d,x);                   (Control Flow 1.2)
        x=1 ;
        if( y<O ) if( y>O ) x=3;
        else x=5;
        PRINT1 (d,x);                   (Control Flow 1.3)
        if( z=y<O ) x=3;
        else if( y==O ) x=5;
       else x=7;
       PRINT2(d,x,z);                  (Control Flow 1.4)
       if( z=(y==O) ) x=5; x=3;
       PRINT2(d,x,z);                  (Control Flow 1.5)
       if( x=z=y ); x=3;
       PRINT2(d,x,z);                  (Control Flow 1.6)
28 PUZZLFS                                                                                                           J LFS 29
                         Control Flow 1: if Statement               Control Flow 2: whi Ie and for Statements
OUTPUT:                                               What does the following program print?
   x .. 5                    (Control Flow 1.1)         'include "defs.h"
   x .. 5                    (Control Flow 1.2)
   x •  1                    (Control Flow 1.3)         maine )
                                                        (
   x •  7     z .. 0         (Control Flow 1.4)
   x .. 3     z =0           (Control Flow 1.5)               int x, y, Z;
   x •  3     z =            (Control Flow 1.6)
                                                              x=y=O;
                                                              while( y<10 ) ++y; x += y;
                                                              PRINT2(d,x,y) ;                     (Control Flow 2.1)
 ~ns      begin on page 105.
                                                              x=y=O;
                                                              while( y<10 ) x += ++y;
                                                              PRINT2(d,x,y);                      (Control Flow 2.2)
                                                              y=1 ;
                                                              whi le ( y< 1 0 )
                                                                     x = y++; z = ++y;
                                                              }
                                                              PRINT3(d,x,y,z);                   (Control Flow 2.3)
                                                              fore y=1; y<10; y++ ) x=y;
                                                              PRINT2(d,x,y) ;                    (Control Flow 2.4)
                                                              fore y=1;     (x=y)<10; y++ )
                                                              PRINT2 (d,x,y);                    (Control Flow 2.5)
                                                              fore x=O,y=1000; y>1; x++,y/=10 )
                                                                     PRINT2 (d, x, y) ;          (Control Flow 2.6)
30 PUZZLES                                                                                                                • _.2LES 31
                                                                               Control Flow 3: Statement Nesting
                 Control Flow 2: whi Ie and for Statements
                                                           What does the following program print?
OUTPUT:                                                      linclude "defs.h"
                                                            Idefine    ENUF 3
                Y = 10                (Control Flow 2.1)
   x • 10                                                    Idefine   EOS '\.0'
   x • 55       y ,. 10               (Control Flow 2.2)
                                                            Idefine    NEXT(i) input[i++]
          9     Y = 11 Z       II: 11 (Control Flow 2.3)
   x  •                                                     Idefine    FALSE 0
   x  ..  9     Y = 10                (Control Flow 2.4)
                                                            Idefine    TRUE 1
   x  ..  10    y = 10                (Control Flow 2.5)
   x  •   0     y = 1000              (Control Flow 2.6)    char input[]="PI=3.14159, approximately";
   x .. 1       Y .. 100                                    main( )
   x .. 2       Y .. 10                                     {
                                                                   char C;
                                                                    int done, high, i, in, low;
Derivations begin on page 108.                                     i=low=in=high=O;
                                                                   while( C=NEXT(i) 1= EOS )
                                                                          if( c<'O' ) low++;
                                                                          else if( c>'9' ) high++;
                                                                          else in++;
                                                                   PRINT3(d,low,in,high);                            (Control Flow 3. J)
                                                                   i=low=in=high=O; done=FALSE;
                                                                   while( (c=NEXT(i» I=EOS && Idone
                                                                          if( c<'O' ) low++;
                                                                          else if( c>'9' ) high++;
                                                                          else in++;
                                                                          if( low>=ENUF I I high>=ENUF I I in>=ENUF
                                                                                 done = TRUE;
                                                                   PRINT3(d,low,in,high);                           (Control Flow 3.2)
                                                                   i=low=in=high=Oj done=FALSE;
                                                                   while( (c=NEXT(i»I=EOS && Idone
                                                                          if ( c<' 0' ) done ,. (++low==ENUF);
                                                                          else if( c>'9' ) done = (++high==ENUF);
                                                                          else done = (++in==ENUF);
                                                                   PRINT3(d,low,in,high);                           (Control Flow 3.3)
32 PUZZLES                                                                                                                        LZlES 33
                        Control Flow 3: Statement Nesting          Control Flow 4: swi tch, break, and continue Statements
OUTPUT:                                                          What does the following program print?
   low .. 25        in .. 0     high .. 0    (Control Flow 3.1 )   #include "defs.h"
   low = 3          in = 6      high = 16    (Control Flow 3.2)
   low '"' 0        in = 0      high = 3     (Control Flow 3.3)    char input[] = "SSSWILTECH1\1\11W\1WALLMP1";
                                                                   main( )
                                                                   {
Derivations begin on page 112.                                           int i, c;
                                                                         forI i=2; (c=input[i]) 1='\0'; i++) {
                                                                                 switch(c) {
                                                                                 case 'a': putchar('i'); continue;
                                                                                 case '1': break;
                                                                                 case 1: while( (c=input[++i]II=='\1' && cl=='\.O' )
                                                                                 case 9: putchar('S');
                                                                                 case 'E': case 'L': continue;
                                                                                 default: putchar(c); continue;
                                                                                 }
                                                                                 putchar (' ');
                                                                         pu tchar ( , \n ' ) ;                             (Control Flow 4. J )
34 PUZZLES
                                                                                      Programming Style
   Control Flow 4: swi tch, break, and continue Statements
                                                                                      1.  Choose the Right Condition
                                                                                      2.  Choose the Right Construct
OUTPUT:
   SWITCH SWAMP                (Control Flow 4.1)
Derivation begins on page 114.
                                                           Much has been written about programming style, about which constructs to
                                                           avoid and which to imitate. A cursory conclusion from the seemingly diverse
                                                           advice is that good style is largely a matter of personal taste. A more reasoned
                                                           conclusion is that good style in programming, as elsewhere, is a matter of good
                                                           judgement. And while there are many good style guidelines, there are few
                                                           always appropriate, always applicable style rules.
                                                           With this in mind, the following puzzles illustrate a few common style
                                                           blunders. The solutions given are not so much answers, as in other sections,
                                                           but rather alternatives. If there is an overall lcey to good style, it is a
                                                           recognition of the final two steps in writing a readable program:
                                                            • Establish a clear statement of the idea to be coded .
                                                            • Develop the structure of the code from the structure of the idea statement.
                                                                        PUZZLES 37
           Programming Style 1: Choose the Right Condition
Improve the following program fragments through reorganization.
  while (AI {
         if(B) continue;
         C;
   }                                            (Programming Style 1.1)
  do {
         if( IA) continue;
         else B;
         C;
  } while(A);                                   (Programming Style 1.2)
  if(A)
         if(B)
                if(C) D;
                else;
         else;
  else
         if(B)
                if(C) E;
                else F;
         else;                                  (Programming Style 1.3)
  while ( (c=qetchar ( ) ) I .. ''\n' ) {
         if( c==' , ) continue;
         if( c==',\t' ) continue;
         if( c<'O' ) return(OTHER);
         if( c<='9' ) return(DIGIT);
         if( c<'a' ) return(OTHER);
         if( c<='z' ) return(ALPHA);
        return(OTHER);
                                                              Storage Classes
                                                                 1.  Blocks
                                                                 2.   Functions
                                                                 3.  More Functions
Derivations begin on page 119.                                   4.  Files
                                 Each variable in C possesses two fundamental properties, type and storage class.
                                 Type has been covered in an earlier section.
                                 Storage class determines the scope and lifetime for a variable. scope being that
                               . part of a program in which a variable is known and lifetime being that portion
                                 of an execution during which a variable has a value. The boundaries of scope
                                 and lifetime are blocks, functions, and files.
IS                                                                                                          PUZZL~      39
                                                Programming Style 2: Choose the Right Construct
                                   Improve the following program fragments through reorganization.
   Derivations begin on pIlge 117.
                                     done .. i .. O;
                                     while( i<MAXI && Idone ) {
                                             if( (x/=2»1 ) (i++; continue; }
                                             done++;
                                     }                                                             (Programming Style 2.1~
                                             if(A) { B; return;      }
                                             if(e)     D; return;    }
                                             i f (E) { F; return;    }
                                            Go, return;
                                     }                                                             (Programming Style 2.2)
                                     plusflqazeroflq-neqflq-O;
                                     if( a>O ) ++plusflq;
                                     if( a-=O ) ++zeroflq;
                                     else if( Iplusflq ) ++neqflq;                                 (Programming Style 2.3)
                                     i=O;
                                     while«c=qetchar(»I-EOF){
                                     if(cl='\n'&&cl='\t'){s[i++]=c;continue;}
                                     if(c=='\n')break;
                                     if(c.a'\t')c=' 'i
                                     s[i++]=Ci}                                                   (Programming Style 2.4)
                                     i f ( x 1=0 )
                                             if( j>k ) y.j/x;
                                            else yak/x;
                                     else
                                            if( j>k ) y-j/NEARZERO;
                                            else y-k/NEARZERO;                                    (Programming Style 2.5)
                                                                 PUZZLES 43
                            Storage Classes 1: Blocks
What does the following program print?
  #include "defs.h"
  int i=O;
  main( l
  {
        auto int i=1;
        PRINT 1 (d, i l ;
         {
                int i=2;
                PRINT 1 ( d , i l ;
                {
                      i   += 1;
                      PRINT1(d,il;
                }
                PRINT 1 ( d , i l ;
        PRINT1 (d, i l;                    (Storage Classes 1.1)
                                                                                                                                PUZZLES
44 PUZZL~
                                Storage Classes 1: Blocks                           Storage Classes 2: Functions
                                                          What does the following program print?
OUTPUT:
                        (Storage Classes 1.1)               'include ndefs.h"
   i  • 1
   i  • 2
                                                            'define LOW 0
   i  •   3
                                                            'define HIGH 5
   i  = 3
                                                            'define CHANGE 2
   i  = 1
                                                            int i=LOW;
Derivations begin on page 123.                              main( )
                                                            (
                                                                  auto int i=HIGH;
                                                                  reset( i/2 ); PRINT1(d,i);
                                                                  reset( i=i/2 ); PRINT1(d,i);
                                                                  i = reset( i/2 ); PRINT1(d,i);
                                                                  workover(i); PRINT1(d,i);               (Storage Classes 2.1)
                                                            workover(i)
                                                            int i;
                                                                  i = (i%i) * «i*i)/(2*i)          +  4);
                                                                  PRINT 1 (d , i ) ;
                                                                  return(i);
                                                            int reset(i)
                                                            int i;
                                                                  i = i<=CHANGE ? HIGH           LOW;
                                                                  return( i);
                                                            }
46 PUZ2LES                                                                                                                  'UZ2LFS 4
                              Storage Classes 2: Functions                      Storage Classes 3: More Functions
                                                           What does the following program print?
OUTPUT:
                                                              #include "defs.h"
    i  ..  5             (Storage Classes 2.1)
                                                            ~ int i.1;
    i  . 2                                                    lDain( )
    i  .   5
                                                               {
                                                                     auto int i, j;
    i  •   0
    i
       -   5
                                                                     i .. reset ( ) ;
                                                                     fort j.1; j<-.3; j++ ) {
                                                                           PRINT2(d,i,j);
                                                                           PRINT1(d,next(i»;
 Derivations begin on page J24.                                            PRINT1(d,last(i»;
                                                                           PRINT1(d,new(i+j»;         (Storage Classes 3.1)
                                                                     }
                                                              }
                                                              int reset()
                                                              {
                                                                    return(i);
                                                              int next(j)
                                                              int j;
                                                              {
                                                                    return( j=i++ );
                                                              int last (j)
                                                              int j;
                                                              {
                                                                    static int i-10;
                                                                    return( jai-- ) ;
                                                              iDt new(i)
                                                              int i;
                                                              {
                                                                   auto int j-10;
                                                                    return( i-j+-i     ) ;
                                                                                                                                     JZZLES 49
48 PUZZLES
                          Storage Classes 3: More Functions                                 Storage Classes 4: Files
                                                            What does the following program print?
 OUTPUT:
                                                                #include "defs.h"
    i   _ 1        j   = 1   (Storage Classes 3.1)
                                                                int i=1;
    next(i) = 1
    last(i) .. 10                                               maine )
                                                                (
    new(i+j) = 12
     i .. 1         j=2                                                 auto int i, j;
     next(i) = 2                                                        i = reset();
      last(i) = 9                                                       for ( j = 1; j < =3; j + + ) {
      new( i+j) = 13
                                                                              PRINT2(d,i,j);
      i=1            j .. 3
                                                                              PRINT1(d,next(i»;
      next(i) .. 3
                                                                              PRINT1(d,last(i»;
      last(i) .. 8
                                                                              PRINT1(d,new(i+j»;                           (Storage Classes 4.1)
      new(i+j) • 14
  Derivations begin on page 125                             Ia QIIOI~r file                            In yet another file
                                                                atatic int i-10;                           extern int i;
                                                                int next( )                                reset( )
                                                                (                                          {
                                                                         return( i+=1     ) ;                   return(i);
                                                                int last( )
                                                                (
                                                                        return( i-=1      ) ;
                                                                int new( i)
                                                                int i;
                                                                (
                                                                        static int j=5;
                                                                        return( i=j+=i ) ;
                                                                )
50 PUZZLES
                                                                                     .I.  ointers and Arrays
                                 Storage Classes 4: Files
                                                                                         1. Simple Pointer and Array
                                                                                         2. Array of Pointers
OUTPUT:
                                                                                         3. Multidimensional Array
                             (Storage Classes 4.1 )                                      4. Pointer Stew
   i   .. 1       j  =
   next(i) .. 11
   last(i) .. 10
   new(i+j) .. 7
   i=1             j=2
   next(i) = 11
    last(i) .. 10
   new(i+j) .. 10
    i-1            j=3
    next(i) = 11
     hst(i) .. 10
    new(i+j) .. 14
 Derivations begin on page 127.
                                                          Pointers have long been abused by programmers and thus maligned in style
                                                          guides. Specifically, pointers are criticized since, by their nature, it is
                                                          impossible to identify fully a pointer's referent without backing up to where the
                                                          pointer was last defined; this adds complexity to a program and makes
                                                          verification much more difficult.
                                                          The C language, rather than restricting the use of pointers, often makes them
                                                          the natural choice for use. As the following puzzles will illustrate, pointers and
                                                          arrays are very closely related. For any application using array indexing, a
                                                          pointer version also exists. The warnings against the dangers of pointer misuse
                                                          apply as strongly to C as to any language.
                                                                                                           51
                                                               PUZZLES
           Pointers and Arrays 1: Simple Pointer and Array
What does the following program print?
  linclude "defs.h"
  int a[)={O,1,2,3,4};
  maine )
  {
        int i, *p;
        fore i=O; i<=4; i++ ) PR(d,a[i);           (Pointers and Arrays 1.1)
        NL;
        fore p= &a[O); p<=&a[4); p++ )
               PR(d,*p) ;                          (Pointers and Arrays 1.2)
        NL; NL;
        fore p= &a[O),i=1; i<=5; i++
               PR ( d , P [ i ) ) ;                (Pointers and Arrays 1.3)
        NL;
        fore p=a,i=O; p+i<=a+4; p++,i++
               PR(d,*(p+i»;                        (Pointers and Arrays 1.4)
        NL; NL;
        fore p=a+4; p>=a; p-- ) PR(d,*p);          (Pointers and Arrays 1.5)
        NL;
        fore p=a+4,i=O; i<=4; i++ ) PR(d,p[-i); (Pointers and Arrays 1.6)
        NL;
        fore p=a+4; p>=a; p-- ) PR(d,a[p-a);       (Pointers and Arrays 1.7)
        NL;
i4 PUZZLES                                                                                                                                                     ,LES 55
               Pointers and Arrays 1: Simple Pointer and Array                                          Pointers and Arrays 2: Array of Pointers
rJUTPUT:                                                                               What does the following program print?
    &[i]     •  0      ali]    • 1   ali] • 2    &[i]   . 3      ali] = 4                #include "defs.h"
                                                             (Pointers and Arrays 1.1)
     •p • 0            .p ... 1      •p = 2      *p ... 3        .p • 4                  int a[]={O.1.2.3.4};
                                                             (Pointers and Arrays 1.2)   int *p[]={a.a+1.a+2.a+3.a+4};
                                                                                         int **pp=pj                                      (Pointers and Arrays ~.1)
    p[i] =             p[i]    • 2   p[i] = 3    p[i] • 4        p[i] = ?
                                                             (Pointers and Arrays 1.3)  maine )
     .(p+i) '"' 0      *(p+i) '"' 2  *(p+i) = 4              (Pointers and Arrays 1.4)   {
                                                                                               PRINT2(d.a.*a)j
     •p   =4           *p = 3        *p .. 2     *p = 1           *p • 0                       PRINT3(d.p.*p.**p);
                                                             (Pointers and Arrays 1.5)         PRINT3(d.PP.*PP.**pp)j                    (Pointers and Arrays 2.2)
     p[-i] = 4         p[-i] = 3     p[-i] = 2   p[-i] = 1        p[-i] .. 0                   NL;
                                                             (Pointers and Arrays 1.6)
     alp-a] = 4         alp-a]   • 3 alp-a]  . 2 alp-a]   .. 1 alp-a] = 0                      pp++j PRINT3(d,pp-p,*pp-a,**pp)j
                                                             (Pointers and Arrays 1.7)         *PP++j PRINT3(d.pp-p.*pp-a.**pp);
                                                                                               *++ppj PRINT3(d,pp-p.*pp-a,**pp);
                                                                                               ++*PPj PRINT3(d,pp-p.*pp-a.**pp);         (Pointers and Arrays 2.3)
                                                                                               NL;
Derivations begin on page 129.
                                                                                               pp=pj
                                                                                               **PP++j PRINT3(d,pp-p.*pp-a.**pp)j
                                                                                               *++*PPj PRINT3(d.pp-p,*pp-a,**pp)j
                                                                                               ++**pp; PRINT3(d,pp-p.*pp-a.**pp)j        (Pointers and Arrays 2.4)
                                                                                        }
56 PUZZLES                                                                                                                                            ruZZLES 57
                     Pointers and Arrays 2: Array of Pointers                                     Pointers and Arrays 3: Multidimensional Array
OUTPUT:                                                                               What does the following program print?
                              *a .. 0                      (Pointers and Arrays 2.2)    'include "defs.h"
   4   .. address of a
   p = address of p           *p .. address of a **p = 0
   pp = address of p          *pp = address of a **pp ,. 0                              int a[3][3] = {
                                                                                               { 1, 2, 3 } ,
   pp-p     .  1     *pp-a     .. 1  **pp"     1           (Pointers and Arrays 2.3)           { 4, 5, 6 } ,
   pp-p     .  2     *pp-4     =  2  **pp"     2
                                                                                        };
                                                                                                 7, 8, 9 }
   pp-p = 3          *pp-a     .. 3  **pp"     3
   pp-p     .. 3     *pp-A     .. 4  **pp"     4                                       int *pa[3] = {
                                                                                              a[O], a [ 1 ] , a[2]
   pp-p .            *pp-4 .. 1      **pp .. 1              (Pointers and Arrays 2.4)   };
               1
    pp-p = 1         *pp-a ,. 2      **pp .. 2                                         int *p = a [ 0 ] ;                                 (Pointers and Arrays 3.1)
    pp-p = 1         *pp-4 .. 2      **pp" 3
                                                                                       maine )
                                                                                        (
                                                                                              int i;
 Derivations begin on JKlge 132.
                                                                                              fore i=O; i<3; i++
                                                                                                     PRINT3(d, a[i][2-i], *a[i], *(*(a+i)+i) ) ;
                                                                                              NL;                                        (Pointers and Arrays 3.2)
                                                                                              fore i=O; i<3; i++
                                                                                                     PRINT2(d, *pa[i] , p[il ) ;         (Pointers and Arrays 3.3)
58 PUZZLE                                                                                                                                                            ZLES 59
                Pointers and Arrays 3: Multidimensional Array                                                   Pointers and Arrays 4: Pointer Stew
OUTPUT:                                                                                    What does the following program print?
     &[i][2-i] = 3            *&[i] .  1 * ( * (&+ i) + i) .. 1 (Pointers and Arrays 3. 21  'include "defs.h"
     &[i][2-i] = 5            *&[i] .. 4 *(*(&+i)+i)       .. 5
      &[i][2-i] .. 7          *&[i] .. 7 *(*(&+i)+i)       .. 9                             char *0£ ]    .   {
                                                                                                   "ENTER",
      *p&[i]     .. 1         p[i]  •  1                        (Pointers and Arrays 3.11          "NEW" ,
      *p&[i]     .. 4          p[i] •  2                                                           "POINT",
      *p&[i] .. 7              p[i] .. 3                                                           "FIRST"
                                                                                             } j
                                                                                            char **cp[] = { c+3, c+2, c+1, c        }j
                                                                                            char ***cpp = cp;                                (Pointers and Arrays 4.1)
 Derivations begin on page 136.
                                                                                            maine )
                                                                                            {
                                                                                                   printf("%s", **++cpp )j
                                                                                                   printf("%s ", *--*++cpp+3 )j
                                                                                                   printf("%s", *cpp[-2]+3 );
                                                                                                   printf("%s~n", cpp[-1][-1]+1 );           (Pointers and Arrays 4.2)
60 PUZZLES                                                                                 ~tructures
                       Pointers and Arrays 4: Pointer Stew
                                                                                 1. Simple Structure, Nested Structure
                                                                                 2. Array of Structures
OUTPUT:                                                                          3. Array of Pointers to Structures
   POINTER STEW                (Pointers and Arrays 4.1)
Derivation begins on page 138.
                                                           A structure, that is the C data type struct, is a fundamental building block
                                                           (or data structures. It provides a convenient way to package dissimilar but
                                                           related data items.
                                                                                                          61
                                                                  PUZZLES
            Structures 1: Simple Structure, Nested Structure
What does the following program print?
  #include "defs.h"
  maine )
  {
        static struct S1 {
               char c[41, *s;
        } s1 = { "abc", "def" };
        static 8truct S2 {
               char *cp;
               struct S 1 s81;
        } 82 = { "ghi", { "jkl", "mno" } };           (Structures 1.1)
        PRINT2(c, 81.c[o1, *S1.8);                    (Structures 1.2)
        PRINT2(8, s1.c, 81.8);                        (Structures 1.3)
        PRINT2(8, s2.cp, 82.S81.8);                   (Structures 1.4)
        PRINT2(8, ++82.cp, ++82.881.s);               (Structures 1.5)
 }
64 PUZZLE                                                                                                                     JZZLFS 6S
              Structures 1: Simple Structure, Nested Structure                         Structures 2: Array of Structures
OUTPUT:                                                          What does the following program print?
     s1.c[0] • a              *s1.s • d         (Structures] .2)   linclude "defs.h"
     s1.c = abc               s1.s = def        (Structures ].3)
     s2.cp = ghi              s2.ss1.s = mno    (Structures].4 )   atruct 51 {
     ++s2.cp = hi·            ++82.881.8 = no   (Structures 1.5)         char *S;
                                                                         int i;
                                                                         struct 51 *s1p;
Derivations begin on page ]"].
                                                                  aain( )
                                                                   {
                                                                         static struct S1 a[] = {
                                                                                { "abcd", 1 , a+1 } ,
                                                                                { "efgh", 2, a+2 } ,
                                                                                { "ijkl", 3, a }
                                                                         } ,.
                                                                         struct 51 *p       = a;                         (Structures 2.1)
                                                                         int i;
                                                                         PRINT3(s, a[O].s, p->s, a[2].s1p->s);           (Structures 2.2)
                                                                         for ( i = 0; i '< 2; i + + ) {
                                                                                PR(d, --a[i].1);
                                                                                PR(c, ++a[1].s[3]);                      (Structures 2.3)
                                                                                NL;
                                                                         PRINT3(s, ++(p->s), a[(++p)->i].s, a[--(p->s1p->1)].s);
                                                                                                                         (Structures 2.4)
                                                                                                                                                 P     LES 67
66 PUZZLES
                          Structures 2: Array of Structures                                      Structures 3: Array of Pointers to Structures
                                                                                   What does the following program print?
OUTPUT:
                                                                                    linelude "deta.h"
   a[O].s      = abed       p->s = abed            a[2].s1p->s = abed
                                                                  (Strudures 2.2)    struet S1 {
                             ++a[i].8[3] = e                      (Structures 2.3)          char *s;
   --a[i1.i • 0
    --a[ i]. i =             ++a[i].s[3] = i                                                struet 51 *s1p;
    ++(p->s) = bee          a[(++p)->i].s = etgi   a[--(p->s1p->i)].s. ijkl          };
                                                                  (Strudures 2.4)
                                                                                     llain( )
                                                                                     {
 Derivations begin on page 145.
                                                                                            static struct 51 al] • {
                                                                                                   { "abcd". a+1 }
                                                                                                   { "efgh". a+2 }
                                                                                                                      ..
                                                                                                   { "ijJtl". a }
                                                                                            } ;
                                                                                            struct 51 *p[3];                                   (Structures 3.1)
                                                                                            int i i
                                                                                            fore i-Oj i<3; i++ ) p[i] - a[i].s1p;
                                                                                            PRINT3(s. p[O]->s. (*p)->a. (**p).s);              (Structures 3.2)
                                                                                            awap(*p.a) ;
                                                                                            PRINT3(s. p[O]->s. (*p)->a. (*p)->s1p->s);         (Structures 3.3)
                                                                                            swap(p[O]. p[01->a1p);
                                                                                            PRINT3(s, p[O]->s, (*++p[ol).s, ++(*++(*p)->s1p).a);
                                                                                                                                               (Structures 3.4)
                                                                                      ••• p(p1.p2 )
                                                                                      .truct S1 *p1. *p2;
                                                                                      {
                                                                                            char *temp;
                                                                                            temp • p1->s;
                                                                                            p1->s • p2->s;
                                                                                            p2->s .. temp;
                                                                                      }
68 PUZZLJ
                                                                                                                    Preprocessor
                  Structures 3: Array of Pointers to Structures
                                                                                                          1. The Preprocessor Doesn't Know C
OUTPUT:                                                                                                   2.   Caution Pays
  p[O]->s • efqh             (*p)->s • efqh  (**p).s = efqh      (Structures 3.2)
  p[O]->s = abed             (*p)->s • abed  (*p)->s1p->s = ijkl (Structures 3.3)
  p[O]->s • ijkl             (*++p[O]).s • abed    ++(*++(*p)->s1p).s. jkl
                                                                 (Structures 3.4)
Derivalions begin on page 152.
                                                                                   Though in a strict sense the preprocessor is not part of the C language, few C
                                                                                   programs would compile without it. Its two most important functions are
                                                                                   macro substitution and file inclusion.
                                                                                  This section concentrates on macro substitution. When used judiciously,
                                                                                  macros are a versatile tool that can enhance the readability and efficiency of a
                                                                                  program. When used unwisely, macros, like other features in C, can lead to
                                                                                  insidious bugs. To solve the puzzles in this section, follow the rules for
                                                                                  expanding macros very carefully.
                                                                                                                                69
                                                           PUZZLES ••
          Preprocessor 1: The Preprocessor Doesn't Know C
What does the following program print?
  'include <stdio.h>
  'define FUDGE(k)           k+3.141S9
  'define PR(a) printf(-a= "d't",(int)(a»
  'define PRINT(a)           PR(a); putchar("n')
  'define PRINT2(a,b) PR(a); PRINT(b)
  'define PRINT3(a,b,c)            P~(a); PRINT2(b,c)
  'define MAX(a,b)           (a<b ? b : a)
  maine )
  {
        {
               int x=2;
               PRINT( x*FUDGE(2)       >;             (Preprocessor 1.1)
        }
        {
               int eel;
               fore eel-O; eel<-100; cel+aSO
                      PRINT2( eel, 9./S*cel+32 );     (Preprocessor 1.2)
        }
        {
               int x-1, y a 2;
               PRINT3( MAX(x++,y),x,y );
               PRINT3( MAX(x++,y),x,y );              (Preprocessor 1.3)
  }
72 PUZZLES                                                                                                                                       P    LES 73
             Preprocessor 1: The Preprocessor Doesn't Know C                                         Preprocessor 2: Caution Pays
                                                                             What does the following program print?
OUTPUT:
                                                                              linclude <stdio.h>
   x*FUDGE(2) = 7                                         (Preprocessor I./j  Idefine NEG(a)-a
   cel= 0          cel= 50     cel= 100 9./5*cel+32 ~ 302 (Preprocessor III   Idefine weeks(mins) (days(mins)/7)
   MAX(x++,y)= 2               x= 2     y .. 2            (Preprocessor I.JJ  Idefine days(mins~ (hours(mins)/24)
   MAX(x++,y)= 3               x'"' 4   Y = 2                                 Idefine hours(mins) (mins/60)
                                                                              Idefine mins(secs)          (secs/60)
                                                                              Idefine TAB(c,i,oi,t)             if(c=='\t')\
                                                                                                                   for(t-S-(i-oi-1)XS,oi=i; t; t--)\
Derivations begin on page 158.
                                                                                                                      putchar(' ')
                                                                              Idefine PR ( a )           printf("a= Xd\t",(int)(a»
                                                                              Idef ine PRINT ( a )       PR(a); putchar('\n')
                                                                              aain( )
                                                                              (
                                                                                            int x=1;
                                                                                            PRINT( -NEG(x)      );                          (Preprocessor 2.1)
                                                                                      }
                                                                                            PRINT( weeks(100BO) );
                                                                                            PRINT( days(mins(B6400»        );              (Preprocessor 2.2)
                                                                                     }
                                                                                            static char input[] = "\twhich\tif?";
                                                                                            char c;
                                                                                            int i, oldi, temp;
                                                                                            fore oldi= -1,i=0; (c=input[i])I='\O'; i++
                                                                                                  if( c<' , ) TAB(c,i,oldi,temp);
                                                                                                  else putchar(c);
                                                                                                  putchar ( , \n' ) ;                      (Preprocessor 2.3)
                                                                                     }
74 PUZZLES
                               Preprocessor 2: Caution Pays
OUTPUT:
     -NEG(x)= 0                             (Preprocessor 1.1)
     weeks(10080) • 1                       (Preprocessor 2.2)
     days(mins(86400»             = 1
     eleven spaces                          (Preprocessor 1.3)
Derivations begill 011 page' 161.
                                                               SOLUTIONS
                                                        BASIC ARITHMETIC OPERATORS ..
Operators 1.1
        x =- 3   + 4  * 5 - 6          Begin by reading the precedence table in Appendix 1
                                       from high to low.
        x = (-3) + 4    * 5 - 6        The highest level operator in the expression is the
                                       unary -. We'll use parentheses to indicate the order
                                       of binding operands to operators.
        x = (-3) + (4*5) - 6           Next highest in the expression is  *.
        x = «-3)+(4*5»         - 6     Both + and - are at the same precedence level. The
                                       order of binding thus depends on the associativity rule.
                                       for that level. For + and -, associativity is left to
                                       right. First the + is bound.
        x= «(-3)+(h5»-6)               And then the -.
        (x=«(-3)+(4*5»-6»              And finally, near the bottom of the precedence table,
                                       is =. Now that we have completely identified the
                                       operands for each operator, we can evaluate the
                                       expression.
        (x=«-3+(4*5»-6)                For this expression, evaluation proceeds from the
                                       inside out.
        (x=«-3+20)-6)                  Replace each sUbexpression by its resulting value.
        (x=(17-6»
        (x= 11 )
        11 • an integer                The value of an assignment expression is the value of
                                       the right-hand sid, cast in the type of the left-hand
                                       side.
  About print! Printf is the formatted print routine that comes as part of the standard C
  library. The first argument to printf is a format string. It describes how any remaining
  arguments are to be printed. The character " begins a print specification for an argument.
  In our program, "d told printf to interpret and print the next argument as a decimal
  number. We will see other print specifications in later programs. Printf can also output
  literal characters. In our program, we "printed" a newline character by giving its name
  (\n) in the format string.
78 BASIC ARITHMETIC OPERATORS                                                                                                                    BASIC ARITHMETIC OPERATORS 79
                                                                                       Operators 1.4
Operators 1.2
       x_3+4"5-6                  This expression is very similar to the previous one.         x =( 7   + 6 ) " 5  I 2        Of course we are not totally at the mercy of predefined
                                                                                                                              precedence. Parentheses can always be used to effect
       x = 3 + (4"5) - 6          Following precedence                                                                        or clarify a meaning.
       x = (3+(4"5»    - 6        and associativity                                            x=(7+6)"5/2                    Subexpressions within parentheses bind first.
       x= «3+(4"5»-6)             leads to                                                     x = «7+6)"5) ~. 2              Then. it is according to the precedence and associativity
                                  this. (The modulo, ", operator yields            the                                        rules as before.
       (x"( (3+(4"5) )-6»
                                  remainder of dividing 4 by 5.)                               x= «(7+6)"5)/2)
        (x-«3+4)-6)               Again, evaluation is from the inside out.                    (x=«(7+6)"5)/2»
        (x-(7-6»                                                                               (x=«13"5)/2»                   Evaluating.
        (x=1)                                                                                  (x=(3/2»
        1                                                                                      (x= 1)                         Integer arithmetic truncates any fractional part.
                                                                                               1
 Operators 1.3
                                                                                         About programming style. As mentioned in the Preface, the programs in this book are not
                                                                                         models to be copied. They were designed to make you think about the mechanics of how C
                                   This expression is a bit more complex than the        works. But the puzzles do contain messages about program style. If a construct always
                                   last, but rigorous adherence to precedence and        forces you to consult a reference to find out how some detail is handled, then the construct
                                   associativity will untangle it.                       is either not well written or it should be accompanied by a comment that provides the
                                                                                         missing details.
        x= (-3) *4,,(-6) IS
                                                                                         The message from this first set of puzzles is to use parentheses in complex expressions to
        x   D «-3)*4)" (-6) 15      *, ", and I are all at the same precedence level,    help the reader associate operands with operators.
                                   and they associate from left to right.
        x = « (-3)*4)"(-6»   15
         x = « «-3)*4),,(-6) )/5)
         (x=««-3)*4),,(-6»/5»
          (x=«(-3*4)"-6)/5»         Evaluating from the inside out.
          (x=«-12"-6)/5»
          (x-(O/5»
          (x=o)
          o
80 ASSIGNME,'I' OPERATORS                                                                                                                               ASSIGNMENT OPERATORS 81
Operators 2.1                                                                                 Operators 2.2
        initially x=2                                                                                initially x= 10
        x *= 3 + 2            Again follow the precedence table.                                     x *= y = z = 4
        x*=(3+2)              As we saw earlier, the assignment operators have lower                 x*=y= (z=4)          In this expression all the operators are assignments, hence
                              precedence than the arithmetic operators. (* = is an assignment                             associativity determines the order of binding. Assignment
                              operator.)                                                                                  operators associate from right to left.
         (x*=(3+2) )                                                                                 x *= (y=(z=4»
         (x*=5)                Evaluating.                                                           (x*=(y=(z=4»)
         (x=x*S)               Expanding the assignment to its equivalent form.                      (x*=(y=4) )       , Evaluating.
         (x=10)                                                                                      (x*=4)
         10                                                                                         40
                                                                                              Operators 2.3
   About define. This program begins with the line
             #define PRINTX printf ( ""d\n H, x)
                                                                                                    initially y=4, z=4
   Any line in a C program that begins with the character , is a statement to the.£
                                                                                                    x = Y == z
   w:e~~~cOJ! One job done by the preprocessor is the substitution of one st~ing by another.
   The define statement in this program tells the preprocessor to replace all mstances of the       x = (y==z)           Often a source of confusion for programmers new to C is
   string PRINTX with the string printf( ""d\n" ,x).                                                                     the distinction between = (assignment) and = = (test for
                                                                                                                         equality). From the precedence table it can be seen that
                                                                                                                         = = is bound before =.
                                                                                                    (x=(y==z) )
                                                                                                    (x={ TRUE) )
                                                                                                    (x=1)                Relational and equality operators yield a result of TRUE, an
                                                                                                                         integer 1, or FALSE, an integer o.
                                                                                                                                         LOGIC AND INCREMENT OPL••.•TORS 83
82 ASSIGNt.t~NT OPERATORS
                                                                                    Operators 3.1
Operators 2.4
                                                                                            initially x=2, y= 1, z=O
       initially x.1, za4                                                                   x .. x &.&. Y II z
       x.·(y=z)                                                                                             II z
                                                                                            x = (x&'&'y)                        Bind operands to operators according to precedence.
                          In this expression the assignment has be~n forced to have
        (x ••  (y .. z»   higher precedence than the test for equabty through the           x = « x&.&.y) I I z )
                          of parentheses.                                                    (x= ( (x&'&'y) I I z}'" }
        (x.·")            Evaluating.                                                        (x-«TRUE&'&'TRUE)llz»              Logical operators are evaluated from left to right.
                          The value of the expression is O. Note however ~hat the                                               An operand to a logical operator is FALSE if. it is
        FALSE, or 0        value of x has not changed ( ... does not change Its                                                 zero and _TRUE .ifit_!s_!,!!y!~!I!.~ c:l~~
                           operands), so PRINTX prints 1.                                    (x= ( TRUE I I z) )                The logical AND, &.&., yields TRUE only when both
                                                                                                                                its operands are TRUE, otherwise FALSE.
                                                                                             (x= (TRUE I I whatever)            Once one argument to the OR, I I, is known to be
                                                                                                                                TRUE we know the result of the I I will be TRUE
                                                                                                                                regardless of the other operand. Hence there is no
                                                                                                                                need to evaluate the expression further.
                                                                                             (x=TRUE)
                                                                                             (x=1 )
                                                                                      More about define. The define statement that begins this program is a little fancier than
                                                                                      that in the previous program. Here, PRINT is the name of a macro with arguments, not just
                                                                                      a simple string. The preprocessor performs two levels of substitution on macros with
                                                                                      arguments: first the .!ctual arguments are substituted for the lp!J!l.l!! arguments in the macro
                                                                                      body, and then the resulting macro body is substituted for the macro call.
                                                                                      For example, in this program PRINT has one formal argument, into PRINT (x) is a call
                                                                                      of PRINT with the actual argument X. Thus, each occurrence of int in the macro body is
                                                                                      first replaced by x, and then the resulting string, printf ( ""d\n n ,x), is substituted for
                                                                                      the call, PRINT (x). Notice that the formal parameter int did not match the middle
                                                                                      letters in printf. This is because the formal arguments of a macro are identifiers; int
                                                                                      only matches the identifier into
                                                                                                                                                              LOGIC AND INCREMENT 01            .TORS 8S
84 LOGIC At          NCREMENT OPERATORS
                                                                                                   Operators 3.4
Operators 3.2
                                                                                                            initially x=2, y= 1, z=O
                                                                                                            z += - x ++ + ++ y
      initially x= 1 , y= 1 , z=O
           I I                                                                                              z += - (x++) + (++y)                        Unary operators associate from right to left,
       X   , I   I Y &.&. z
                                                                                                                                                        thus + + binds before unary -. (Actually, the
       X
           I I
           I I   ( I y) &.&. z           Binding operands to operators.                                                                                 expression would not be legal if it. were
           I
           ,
              I
              I  (( Iy)&.&.z)                                                                                                                           arranged so that the - bound first since + + and
       X
                                                                                                                                                        - - expect a reference to a variable (an lvalue)·
        (x   I I ( ( I Y ) &'&'z) )                                                                                                                     as their operand. x is an IvafUe~ but -x is not.)
        ( TRUE     I I ( ( I y) &'&'z) ) Evaluating from left to right.                                     z += (-(x++»         + (++y)
        ( TRUE     I I whatever)                                                                            z += ((-(x++) )+(++,y»
       TRUE,        or 1                                                                                    (z+=((-(x++»+(++y»)
                                                                                                            (z+= ( (-2) +2) ) , and x=3, y=2            Evaluating from the inside out.
                                                                                                            (z+=O)
Operators 3.3                                                                                               (z   = 0+0)
                                                                                                            (z=O)
       initially x= 1 , y= 1                                                                                o
       Z :: X     ++ -
       Z ::     (x++) - 1                Following precedence.                                    Operators 3.5
       z=((x++)-1)
                                                                                                           initially x=3, z=O
        (z=((x++)-1»
                                         The + + to the right of its operand is a post increment.          z = x I ++ x
        ( z = ( 1-1 ) ) , and x= 2
                                         This means that x is incremented after its value is used          z=x/(++x)
                                         in the expression.
                                                                                                           z = (x/( ++x»
        (z=O)
                                                                                                            (z=(x/(++x)       »
        o
                                                                                                           You may be tempted at this point to begin evaluating this expression as before, from
                                                                                                           the inside out. First the value of x would be retrieved and incremented to be divided
                                                                                                           into the value of x. One question that might be asked is what value is retrieved from x
                                                                                                           for the numerator, 3 or 4? That is, is the value for the numerator retrieved before or
                                                                                                           after the increment is stored? The C language does not specify when such a side
                                                                                                           effect) actually occurs; that is left to the compiler writer. The message is to avoid
                                                                                                           writing expressions that depend upon knowing when a side effect will occur.
                                                                                                  I. A side effect is any change to the state of a program that occurs as a byproduct of executing a
                                                                                                     statement. By rar the most common side effects in C relate to storing intermediate values in
                                                                                                     variables, such as with the increment operator as above or with an embedded assignment operator.
86 BITWISE OPr,l\.ATORS                                                                                                                             BITWISE OPERATORS 87
Operators 4.1                                                                         Operators 4.2
      initially x=03. y.02. z=O 1                                                           initially x=03. y=02. z=O 1
      xly&.z                      Integer constants preceded by 0 (zero) are octal           xly&-z
                                  values. Octal notation is particularly useful when
                                                                                             ( x I (y& ( - z ) ) )
                                  working with the bitwise operators because it is
                                  easy to translate octal numbers to binary. In this         ( x I (y& - 0 1 ) )          - complements each of the bits of its operand.
                                  problem, 01, 02, and 03 are equivalent to 1, 2,                                        Thus O ••• 0 1 becomes 1 ••• 10.
                                  and 3, so using octal is merely a cue to the reader
                                                                                             (xl(02&-01»
                                  that the program will deal with the values of x, y,
                                  and z as bit strings.                                      (03102)                     In binary,
       (x I (y&'z) )              Following precedence.                                                                          0 ••• 010
                                                                                                                              & 1 ••• 110
       (x I (02&01) )             The innermost expression is evaluated first.                                                ---------
                                                                                                                                 0000010
       (x 10)                     In binary, 0 1 - 1, 02- 1 0, 0 3 - 11
                                                                                             3
                                           10
                                       &  01                                                                                    10
                                                                                                                                11
                                          00
                                                                                                                                11
       (0310)
       03
                                          00
                                           11                                         Operators 4.3
                                           11
                                                                                            initially x.03. y.02. z:aO 1
                                                                                            x"y&-z
                                                                                             (x" ( y& ( - z ) ) )        This is the same as the previous problem except
                                                                                                                         that the exclusive or, ", has been substituted for
                                                                                                                         the inclusive or, I.
                                                                                             (x"(02&-01»
                                                                                             (03"02)
                                                                                             1                           In binary,
                                                                                                                                 10
                                                                                                                              A   11
                                                                                                                                 01
88 BITWISE OPERATORS                                                                                                                       BITWISE OPERATORS 89
Operators 4.4                                                                Operators 4.6
      initially x=03, y=02, z=01                                                    initially X=O 1
      x 6. Y 6.6. z                                                                 -xIx
       ( (x6.y) 6.6.z )                                                             «-x)lx)
       «036.02)6.6.z)                                                               (-01101)
       (026.6.z)                                                                    -1               In binary,
       (TRUE6.6.z)                                                                                           1 ••• 110
                                                                                                          I 0 .•. 001
       (TRUE6.6.0 1)
                                                                                                             1 ••• 111, or - 1
       (TRUE6.6.TRUE)
                                                                                                     (The answer is the same for all values of x. Actually, it is -1
       TRUE, or 1                6.6. yields TRUE whenever both operands are
                                                                                                    on a two's-complement machine, like the PDP-II. On a
                                 TRUE.
                                                                                                    one's-complement machine 1 ..• 1 would be -0. For the few
                                                                                                    cases in this book where it matters, two's-complement will be
                                                                                                    used.)
Operators 4.5
                                                                             Operators 4.7
       initially x = 0 1
        Ixlx
                                                                                   initially x=O 1
        «lx)lx)
                                                                                   x"x
        « ITRUE) Ix)
                                                                                   (01"01)
        (FALSEI01)
                                                                                   o                In binary,
        (0 101)
                                                                                                            O ••• 01
        1                                                                                                AD ••• 01
                                                                                                            o ... 00
                                                                                                    (The answer is the same for all values of x.)
  90 BITWISE 0      ATORS                                                                                                              RELATIONAL AND CONDITIONAL OPL ...TORS 91
  q"uo,s 4.8                                                                                            Operators 5.1
I       initially x=O 1                                                                                        initiallyx=3, y=2, z=1
        x «= 3                                                                                                 x<y?y:x
        x .. 01«3                                                                                               (x<y) ? (y) : (x)      The conditional operator, aside from taking three
                                                                                                                                       operands, is parsed like any other operator.
        x.8                       In binary,
                                                                                                                «x<y)?(y): (x»
                                           0000 ••• 01
                                        «             3                                                         (FALSE?(y): (x»        First the condition is evaluated. Then either the
                                              O••• 01000, which is 8                                                                   true part or the false part is evaluated, but not
                                                                                                                                       both.
                                  Each place shifted to the left is an effective multiplication by 2.
                                                                                                               ( (x) )                 In this problem the value of the condition is
                                                                                                                                       FALSE, thus the value of the conditional
                                                                                                                                       expression is the value of the false part.
  Operators 4.9                                                                                                (3)
                                                                                                               3
        initially y=-O 1
         Y  «~a   3                                                                                     Operators 5.2
         y=-01«3
         y. -8                    In binary,
                                                                                                              initially x=3, y=2, z=1
                                           1111 ... 11
                                        «             3                                                       x < y ? x ++ : y ++
                                        -----1:::11000, or -8                                                  «x<y)?(x++):(y++»
                                                                                                              (FALSE?(x++):(y++»      First evaluate the condition.
                                                                                                              ( (y++) )               The condition is FALSE so the false part is
  Operators 4. J0                                                                                                                     evaluated.
                                                                                                              (2), and y==3
                                                                                                              2                       (And since x+ + was not evaluated, x remains 3.)
         initially y=-08
         y »= 3
         y  = -08»3
         It is tempting at this point to assume that y - -1. Unfortunately this is not always tk      '
         case, since the computer may not preserve the sign of a number when shifting. C docI
         not guarantee that the shift will be arithmetically correct. In any case, there is a mllCl
         clearer way to divide by 8, namely y=y/8.
92 RELAl         AL AND CONDmONAL OPERATORS                                                                                     RELATIONAL AND CONDITIO!,,, ... OPERATOR
Operators 5.3                                                                                  Operators 5.5
       initially x.3. y.3. z.1                                                                       initially x=3. y=4. z=4
       z +- x < y? x ++ : y ++                                                                       z > = Y &.&. Y > = x
        (z+=«x<y)?(x++):(y++»)                                                                        «z>=y)&'&'(y>=x) )
        (z+=(FALSE?(X++):(Y++»)                                                                       (TRUE&.&.(y>=x) )      Evaluating from left to right.
        (z+-( (y++»                            The result of the conditional expression is            (TRUE&.&.TRUE)
                                               the right-hand side of the assignment.
                                                                                                     (TRUE)
        (z+-(3». and y.4
        (z=z+3)
        (z-4)
        4
 Operators 5.4
        initially x- 3. y=4. z .. 4
         (z >- y > .. x)        ? 1 : 0
         ( ( ( z> =y ) > -x) ? ( 1 ) : ( 0 ) )
         «TRUE>ax)?(1):(O»                      The condition is evaluated from the inside
                                                out.
         ( ( 1 > .. x) ? ( 1 ) : ( 0 ) )        The value of the innermost relation is
                                                TRUE. It is compared to the integer x.
                                                While this is legal in C, it is really playing
                                                footloose with the value TRUE being an
                                                integer 1, and, as in this problem, it is
                                                usually not what's wanted. (The next
                                                puzzle shows the right way to compare
                                                three values.)
          (FALSE? ( 1 ) : (0) )
          ( (0) )
         o
94 OPERATOR PRECEDENCE AND EVALUATION                                                                                                   OPERATOR PRECEDENCE AND EVALUATION 95
Operators 6.1                                                                                  Operators 6.3
       initiaUy x=1 , Y'" 1, z=1                                                                      initially x= 1, y= 1, z= 1
       + + x I I + + y && + + z                                                                       + + x && + + Y && + + z
        «++x)II«++y)&&(++z»)                       Binding operands to operators.                      «(++x)&&(++y»&&(++z»
        (211 «++y)&&.(++z»), and x-2               Evaluating from left to right.                     ( (2&&2 )&&( ++z) ), and x=2, y=2
        ( TRUE I I whatever)                       Since the left operand of the I I is               (TRUE&&(++z»
                                                   TRUE, there is no need to evaluate                 (TRUE&&TRUE), andz=2
                                                   further. In fact, C guarantees that it
                                                   will not evaluate further. The rule is            TRUE, or 1
                                                   that a logical expression is evaluated
                                                   from left to right until its truth value is
                                                   known. For this problem that means y
                                                   and z remain 1.                             Operators 6.4
        TRUE, or 1
                                                                                                     initially x=-1, y=-1, z=-1
                                                                                                     + + x && + + y : : + + z
 Operators 6.2
                                                                                                     (((++x)&&(++y»II(++z»
                                                                                                     ( (0&& (++y) ) I I (++z) ) , and x=O
        initially x-1, y a 1, z= 1                                                                   ((FALSE&&(++y»II(++z»
         ++ x && ++ y II ++ z                                                                        (FALSE I I (++z) )                        There is no need to evaluate ++y since
         «(++x),,(++y»II(++z»                                                                                                                  the left operand to && is FALSE. The
                                                                                                                                               value of the I I operation is still not
         «TRUE&'(++Y»          II (++z», and x.2                                                                                               known, however.
         «2"2) II (++z», and y.2                    Evaluating from left to right.                   (FALSE: 1(0», and z=O
         ( TRUE I I (+ +Z ) )                                                                        (FALSE I I FALSE)
         TRUE, or 1                                 z is not affected.                               FALSE, or 0
 About eva/1Ullion OI'der and precedence. For most operators, the order of evaluation - is
 determined by precedence. As can be seen from the puzzles in this section, there are a rew
 exceptions to this general rule:
  • Pre- increment and decrement operators are always evaluated before their operand is
    considered in an expression.
  • Post- increment and decrement operators are always evaluated after their operand i
    considered.
96 OPERATOR PRECEDENCE AND EVALUATION                                                                                                                    CHARACTER, STRING, AND INTEGER TYPES 97
                                                                                                      Basic Types J. J
Operators 6.5
                                                                                                               PRINT(d,"5")                      "d format instructs printf to print the argument as a
        initially x=-1 , y=-1, z=-1
                                                                                                                                                 decimal number. n 5" is a pointer to a character array
        + + x I I + + y &.&. + + z                                                                                                               (i.e., the address of the two character array , 5 ' ,
         «++x)II«++y)&'&'(++z»)
                                                                                                                                                 '\0 ').
                                                                                                               PRINT (d, ' 5' )                  "d causes the decimal value of the character ' 5' to be
         (FALSEII «++y)&.&.(++z»), and x=O
                                                                                                                                                printed. I
         (FALSEII (FALSE&'&'(++z»), and y=O
                                                                                                               PRINT(d,s)                       The integer 5 is printed in decimal.
         (FALSEIIFALSEI
         FALSE, or 0
                                                                                                              PRINT( 8, "5")                    "8   format instructs printf that the argument is a
                                                                                                                                                pointer to a character array. Since .. 5 n is a pointer to a
                                                                                                                                                character array, the content of that array,S, is printed.
                                                                                                              PRI NT ( c , ' 5' )               "c format instructs printf to translate the argument
 Operators 6.6                                                                                                                                  into the character its value represents. Since ' 5' is
                                                                                                                                                the encoded value for 5, 5 is printed.
                                                                                                              PRINT(c,s3)                       As seen earlier, the decimal number 53 is the ASCII
         initially x=-1, y=-1, z=-1                                                                                                             code value for the character 5.
                                                                                                              PRINT(d,('5'>5»                   One last time. ' 5' has the integer value 53 which is
         ++ x&.&. ++ Y &.&. ++ z
                                                                                                                                                greater than the integer 5.
          ( ( ( ++ x ) &.&. ( + + y) ) &.&. ( ++ z ) )
          «FALSE&'&'(++y) )&.&.(++z», and x=O
          (FALSE&'&' ( ++ z) )
          FALSE, or 0
   AbouJ side effects in logical expressions. As you have surely learned by now, the evaluation of
   a logical expression can be tricky in C because the right-band part of the expression is
    evaluated conditionflily on the value of the left-band part. Actually. conditional evaluation is
    a useful property of the logical operators. The trouble arises when the right-hand part of a
    logical expression contains a side effect; sometimes the side effect will occur and sometimes
    it won't. So, while in general it is good practice to use side effects carefully, it is vital in
    logical expressions.
                                                                                                     I. The value given here is that for the ASCII character code (see Appendix 3). The ASCII code is but
                                                                                                        one of several ~dcs used by computers to represent characters. It will be used in this book for those
                                                                                                        few cases where It matters.
98 C~AcrER,        ___ .ING, AND INTEGER TYPFS                                                                                            INTEGER AND FLOATING POINl _ ..S1'S 99
Basic Types 1.2                                                                                 Basic Types 2.1
       initially sx=-8, ux=-8                                                                           i = 1 = f = d = 100/3
       PRINT(O,sx)                    "0 instructs printf to print the argument as an octal             (i= (1= (f= (d= (100/3»»)                Evaluation is from right to left.
                                      number.                                                           (i= (1= (f= (d-33)    »)                 Since both 1 0 0 and 3 are integers,
        PRINT(o,ux)                   The value -8 is a string of 1's and O's just as valid for                                                  the division is integer division and
                                      unsigned variables as for signed ones.                                                                     thus the quotient is truncated.
        PRINT(0,sx»3)                 We have seen this problem earlier. With some                      (i= (1= (f=(double)33)    », and d=33    Recall that the value of an
                                      versions of C, right shifting of a signed integer causes                                                   assignment expression is the value
                                      the sign bit to be copied into the vacated high order                                                      of the right-hand side cast in the
                                      bits, thus having the desirable property of preserving                                                     type of the left-hand side.
                                      sign. Beware-lhis is compiler dependent!                          (i= (1=(float)33) ), and f=33
        PRINT(0,ux»3)                 When right shifting an uns igned integer the high                 (i=(10ng)33), and 1=33
                                      order bits are always filled with O's.
                                                                                                        (integer) 33, and i=33
        PRINT(d,sx»3)                 In decimal, right shifting a signed - 8 three places
                                      yields the expected - 1 if sign is preserved, 8 19 1             33, an integer
                                      otherwise (in tWO's-complement on a 16-bit machine).
        PRINT(d,ux»3)                  For an uns igned - 8, the result is always 8191 (on a
                                       16-bit machine).                                         Basic Types 2.2
                                                                                                       d  = f =1  = i = 100/3
                                                                                                       (d:   (f= (1= (i=( 100/3»  »)
                                                                                                       (d= (f= (1=(integer)33)    »,  and i=33
                                                                                                       (d .. (f=(10ng)33) ), and 1=33
                                                                                                       (d=(float)33), and f=33
                                                                                                       ( (double) 33) , and d=33
                                                                                                       33, a double
100 INTEGER     A,~J} FLOATING POINT CASTS                                                                                     INTEGER AND FLOATING POlL      ~ASTS   101
Basic Types 2.3                                                                        Basic Types 2.5
      i = 1 = f = d = 100/3.                                                                  i = 1 = f = d = (double) (10000013)
      (i= (1= (f= (d= (100/3.»            »)                                                  (i= (1= (f= (d= «double) (100000/3»         »»
       (i= (1= (f=(double)33.333333) »                                                        (i= (1= (f= (d=(double)33333)     »)              The operand to the
           and d=33. 333333                      3. is a double so the quotient                                                                 type cast is the quotient
                                                 retains its precision.                                                                         from the integer
                                                                                                                                                division of 100000 by
       (i= (1=(float)33.333333)                                                                                                                 3.
           and f .. 33. 33333x                   The printf specification in this             (i= (1= (f=(double)33333)     ». and d=33333
                                                 program is "". 8g". which tells
                                                 printf to output numbers of up               (i= (1:(float)33333) ). and f=33333
                                                 to eight significant digits. Seven           (i=(long)33333). and 1=33333
                                                 significant digits is about the limit
                                                 of precision for floats on the               ( (integer) 33333) • and i=33333 or overflow      33333 cannot be
                                                 PDP-II and VAX. so the eighth                                                                 represented as a 16-bit
                                                 digit is unreliable. The number of                                                            signed integer. Most
                                                 significant digits is, of course,                                                             implementations of C
                                                 machine dependent.                                                                            will happily permit
                                                                                                                                               arithmetic over- or
       (i=(1ong)33.33333x)          t and 1=33   The float to long conversion is
                                                                                                                                               underflow. When your
                                                 through truncation.                                                                           calculations potentially
       (integer) 33) • and i=33                                                                                                                push the limits of your
                                                                                                                                               machine, it is wise to
       33 t an integer                                                                                                                         insert explicit range
                                                                                                                                               checks.
                                                                                             33333. an integer, or overflow
Basic Types 2.4
       d: f = 1 .. i .. (double) 100/3
       (d= (f: (1= (i= «double) 100) 13»»         Notice that type cast has higher
                                                  precedence than I.
        (d= (f= (1= (i=33.333333) »)
        (d: (f= (1=(integer)33.333333)         »
            and i=33
        (d .. (f=(longl33) )     t and 1=33
        (d- (float) 33)    t and f=33
        « double) 33) • and d=33
        33 t a double
102 INTEGER .... .) FWATING POINT CASlS                                                                                                                                  MORE   '-n~'TS 103
Basic Types 2.6                                                                                        IIsic Types 3.1
       d .. f .. 1 = i .. 100000/3                                                                            initially d=3. 2, i=2
       (d- (f- (1= (i-100000/3) » )                                                                           x = (y=d/i) *2
       (d- (f- (1-(integer)33333) »                                                                            (x= (y=3.2/2) *2)
           and i .. 33333, or overtlow                  As we've seen before, 33333 is                         (x= (y=1.6)*2)       3.2, a double, is of higher type than 2, an into
                                                        overtlow for a 16-bit signed integer.                                       Thus the quotient is a double.
                                                        For integer representations with more
                                                                                                               (x=1*2), and y=1     y, an int, gets 1.6 truncated.
                                                        bits, i would get 33333, as would 1,
                                                        f, and d. We'll continue with the calC                (x=2)
                                                        for 16-bit integers.
                                                                                                              2, and x=2
        (d- (f=(long)-32203)
            and 1--32203                                The result of an operation that leads to
                                                         overflow is a legitimate number, just
                                                         not the number expected. The 33333
                                                                                                   _. lac Types 3.2
                                                         is lost, regardless of future type casts.
        (d-(float)-32203), and f=-32203                                                                      initially d=3. 2, i=2
        ((double)-32203), and d=-32203                                                                       y=(x=d/i)*2
        -32203, a double                                                                                      (y= (x=1.6)*2)
                                                                                                              (y=1.6*2), and x=1.6  Since x is a double, the result of the assignment is a
                                                                                                                                    double.
   About numbers. The treatment of numbers is not one of C's strong points. C does not                        (y .. 3.2)            1.6, a double, determines the type of the product.
   provide a way to catch arithmetic errors even if the hardware so obliges. The range of tile               3, and y=3             y, an int, gets 3.2 truncated.
   numerical data types is fixed by the compiler writer; there is no way to specify a range in the
   language. To achieve range checking, about the best one can do is explicitly test the value
   of variables at critical points in a calculation.
                                                                                                                                                                IF STA._•.• ENT 105
104 MORE     CAS1~
Basic Types 3.3                                                                                 Control Flow J. J
       initially d=3. 2. i=2                                                                           initially y= 1
                                                                                                       if( yl=O ) x=S;             The first step is to evaluate the condition.
       y=d. (x=2.S/d)
        (y. d. (x=2.S/d)                                                                                ( y 1=0 )
        (y= d.2. Sid)      t and x=2. Sid             x is a double, so the precision of                ( 11 =0 )
                                                      2. S/d is retained.                              TRUE                        Since the condition is TRUE, the true part of
                                                                                                                                   the if statement is executed.
        (y=2.S)
        2, and y=2                                    y gets 2. S truncated.                           x  =S
Basic Types 3.4                                                                                 Control Flow J. 2
                                                                                                       initially y= 1
        initially d=3. 2. i=2
        x = d • (y = ( (int) 2.9+ 1. 1) /d)                                                             if ( y==O ) x=3; else x=S;
                                                      Type cast has higher precedence than              ( y==O )                   Evaluate the condition.
         (x=d. (y=(2+1.1)/d)
                                                       +.                                               FALSE
         (x- d. (y=3.1/d) )                                                                            x =S                        Execute the false part of the if statement.
         (x- d. (y=. something)
         (x=d.O)    t and y=O                         y gets 0 regardless of the value of
                                                      "something", since" • something" is
                                                       between 0 and 1.
         0, and x=O
   About mixing types. By now you have seen enough examples of how mixing floating point
   and integer values in expressions can lead to surprises. It is best to avoid arithmetic with
   operands of mixed type. If you do need it, make the type conversions explicit by carefwlly
   using casts.
106 IF STATEMEr-..                                                                                                                                             IF STATE~ __..T 107
Colll1'01 Flow J.3                                                                           Control Flow J .5
         initially y = 1                                                                            initially y= 1
         x=1                                                                                        if( z=(y==O) ) x=Si x=3
         ifC yeO) ifC y>O ) x=3;
         else x-S;                                                                                  if( z=(y==O)        {x=S;} x=3i The true part of an if is the single
                                                                                                                                    statement or block following the condition
                                   First x is assigned 1.                                                                            for the if.
         if(yeO){                  The braces indicate statement nesting.                            ( z=(y==O) )                   Evaluate the condition.
             if(y>O)x .. 3;                                                                          ( z=FALSE )
             else x=5;
          }                                                                                         FALSE. and z=O
          ( yeO )                                                                                   x = 3                           Since the if statement does not have a
                                   The condition of the first if is FALSE, thus the                                                 false part, control falls through to the next
          FALSE                                                                                                                     statement.
                                   true part is skipped. The e 1 s e clause is contained
                                   in the true part of the first if since it belongs to
                                   the second if. The rule in C is that an.::all.L
                                   clause belon8!J.!Llit e closesLg....!..hat..~~acce2t i.!: Control Flow 1.6
Control Flow 1.4                                                                                   initially y= 1
                                                                                                    if( x=z=y ) i x=3i
          initially y .. 1                                                                          if( x=z=y ) { i } x=3i          The true part of the if is a null statement.
          if ( z-yeO ) x=3;                                                                         ( x=(z=y»                       Evaluate the condition.
          else if ( y •• O ) x",S;                                                                  ( x= ( z = 1 ) )
          else x=7;
                                                                                                    ( x= 1 ). and z = 1
           (z=(yeO)                 Begin by evaluating the first condition. We will
                                                                                                   TRUE, and x= 1
                                    use parentheses, as before, to indicate the bindi ll8
                                    of operands to operators.                                      x =3                             The if condition is TRUE, so the true part
                                                                                                                                    of the if is executed. The true part is a
             z.(1<O) )                                                                                                              null statement and has no effect. Finally,
             z·FALSE )                                                                                                              the statement following the if is executed.
           FALSE. and zaO
           ( y •• O )               Since the condition of the first if statement is
                                    FALSE, the false part of the if is executed. The
                                    false part is another if statement, so its conditio8
                                    is evaluated.
           FALSE
           x-7                      The condition is FALSE, thus the false part of the
                                    sec nd if statement is executed.
                                                                                                                                             WHILE AN D FOR STATE          iTS 109
108 WHILE AND I       STATEMENTS
                                                                                      Control Flow 2.2
Control Flow 2.1
                                                                                             initially x= 0, y= 0
      initially x= 0, y= 0
                                                                                              while( y<10 ) x += ++y;
       while( y<10        ++y; x +- y;
                                                                                              ( y< 10 )                                   The loop condition.
       while( y<10) ++y;               Begin by analyzing the factors that control
                                       the execution of the while statement:         •        ( y> = 10                                   The exit condition.
       ( y< 10 )                       The loop condition. The body of the loop is            Y =0                                        The initial value of the control variable.
                                       executed as long as the loop condition                                                             The effect of the loop on the control
                                                                                              ++y
                                       evaluates to TRUE.                                                                                 variable.
                                       The exit condition. The exit condition, the                                                        As in the previous problem.
                                                                                              y = 0 through 9 in the loop
                                        negation of the loop condition, is TRUE
                                       upon a normal termination of the loop.                 x += ++y                                    x gets the sum of the values of y (after
                                                                                                                                          y is incremented) in the loop.
       y.O                             The initial value of the control variable.
                                       This is the value of the control variable              x = 55                                      The sum of the integers 1 to 10.
                                        during the first iteration of the loop body.
                                                                                              y = 10 on exit
        ++y
                                       The effed on the control variable of
                                        executing the body of the loop.
                                        y- 0 the first time in the loop. Each time
                                                                                       Control Flow 2.3
        y _ 0 through 9 in the loop
                                        through the body y is incremented by 1.
        y. 10 on exit                   When y== 10 the loop condition evaluates
                                                                                             initially y= 1
                                        to FALSE and the iteration terminates.
                                        Control passes to the statement following
                                                                                              while( y<10 ) {x          = y++; z = ++y; }
        X +- y;
                                        the loop body.                                        ( y< 10 )                                   The loop condition.
        x.O+10                                                                                ( y> = 1 0                                  The exit condition.
        x. 10                                                                                 Y = 1                                       The initial value of the control variable.
                                                                                             y++, ++y                                     The effect of the loop on the control
                                                                                                                                          variable.
                                                                                              y = 1, 3 , 5 , 7 , 9 in the loop            y= 1 the first time in the loop and is
                                                                                                                                          incremented by 2 each time through
                                                                                                                                          the loop.
                                                                                             x= 1,3,5,7,9                                 x takes on the value of y in the loop
                                                                                                                                          before it is incremented.
                                                                                              z=3,5,7,9,11                                z takes on the value of y in the loop
                                                                                                                                          after it has been incremented by 2.
                                                                                             y = 11 on exit
110 WHILE AND         l STATEMENTS                                                                                         WHILE AND FOR STATF           ITS III
Control Flow 2.4                                                                   Control Flow 2.6
        fore y=1; y<10; y++) x=y;    The for statement aggregates the                     fore x=O,y=1000; y>1; x++,y/=10
                                     controlling factors of the loop.                        PRINT2 ( d, x, y) ;
                                     Loop condition.
                                                                                         y>1
                                     Exit condition.                             ,                                             Loop condition.
                                                                                                                               Exit condition.
                                     Initial value.
                                                                                         y=1000                                Initial value.
        y++                          Effect.
                                                                                         y/=10                                 Effect.
        y • 1 through 9 in the loop
                                                                                         Y • 1 000 , 100 , 10 in tht: loop
        x .. 1 through 9             x gets the value of y in the body of the
                                     loop.                                               x .. 0, 1 , 2 in the loop             x-O from the for statement
                                                                                                                               initialization. x is incremented
        y. 10 on exit                                                                                                          after the body and before the
                                                                                                                               test. (The PRINT2 statement
                                                                                                                              is in the body.)
COnl1'01 Flow 2.5                                                                        y .. 1 on exit
                                                                                         X"   3 on exit
        fore y.1; (x=y)<10; y++ )
        y<10                         Loop condition.
        y>=10                        Exit condition.
        y.1                          Initial value.
        y++                          Effect.
        y .. 1 through 9 in the loop
        X"   1 through 10            x gets the value of y just before the
                                     evaluation of the loop condition. Note that
                                     the condition is evaluated one time more
                                     than the body is executed.
        y .. 10 on exit
      112 STATEMENT NESTING                                                                                                                            STATEMENT NESTING 113
      Control Flow 3.1                                                                         Control Flow 3.3
             initially i=in=high-low .. O, input.·PI-3. 141 S9, approximately·                       initially i=in=high=low=O. done=FALSE.
             while( e-(NEXT(i) I-EOS) )                  The loop condition effectively is                     input="PI=3.141S9, approximately·
                                                          NEXT(i) I=EOS, where
                                                          NEXT ( i) successively takes on the        whi le ( (e=NEXT (i) ) I =EOS && I done) (    e successively takes on the
                                                         character values from input. e                                                            value of each character from
                                                         gets the truth value of                                                                   input.
                                                         NEXT ( i) I "EOS, which, by                 iff ,P'<'O' )                                 FALSE.
                                                         definition, is TRUE in the loop and
                                                          FALSE on exit.                             else iff 'P'>'9'                              TRUE.
             iff 1<'0' ) low++                            e is always 1 in the loop, so low is       done = (++high==ENUF)                        high, after being incremented,
                                                         always incremented (1 < 060).                                                            is not equal to ENUF, so done
                                                                                                                                                  is assigned FALSE. high-1.
            while ( e- (I I-EOS )                        The iteration continues until all the
                                                         characters in input have been               while( ' I ' I=EOS && Idone )                TRUE.
                                                          read. C uses the ASCII nul                 iff '1'<'0' )                                FALSE.
                                                         character, 0 0, as the end of string
                                                          marker.                                    else iff '1'>'9'                             TRUE.
                                                                                                     done .. (++high .... ENUF)                   high=2,done-FALS~
                                                                                                     while( ,=,I=EOS && Idone                    TRUE.
      Control Flow 3.2                                                                               iff '='<'0')                                 FALSE.
                                                                                                     else iff '='>'9'                            TRUE.
            initially i-in-high-low-O, done-FALSE,                                                   done = (++high-=ENUF)                       high=3, done=TRUE.
                       input-·PI-3. 141 S9. approximately·                                           while( '3'I-EOS &&. Idone                   done=TRUE, so
                                                                                                                                                  Idone=FALSE, and the loop
            while( (e-NEXT{i»        I-EOS &.&. Idone )   e successively takes on the value of                                                   terminates.
                                                         each character from input.
             if ( , P' <' 0' )                           The first time through the loop
                                                          e - ' P " hence the if condition is
                                                          FALSE.
             e18e iff 'p'>'9' )                          TRUE, and high+ +.
            while ( , I' I-EOS &&. I done)               Back at the loop test. (The if
                                                         statement comparing low, high,
                                                         and in with ENUF is outside the
                                                         loop, indentation to the contrary.)
                                                         Since done is not effected within
                                                         the loop, the iteration ends when
                                                         e'" EOS. In the loop. the counters
                                                          low, in, and high are
                                                         incremented depending upon the
'-----_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _----'value of e with respect to the digit
114 SWITCH, Bl __.•K, AND CONTINUE STATEMENTS                                                                      SWITCH, BREAK, AND CONTINUESTATL __ NTS 115
                                                                                      ca8e ' l' : break                                The break statement forces
ConlTOl Flow 4.1
                                                                                                                                       an exit from the innermost
                                                                                                                                       enclosing loop or 8wi tch. In
    char input[) ."SSSWIL'1'ECH1\ 1\ 11W\ 1WALLMP1" The character array input is                                                       this case, it causes a branch to
                                                    initialized to the character                                                       the statement following the end
                                                    string "sss ... MP1".                                                              of the 8wi tch.
                                                    c takes character values from     putchar (' ')                                   A space is printed.
                                                     input beginning at the third     for(; (c=input[111)l_'\0'; i++) {                Back at the top of the for
                                                    character.                                                                        loop.
    8witch( 'S') {                                  The first time through the       switch('\1') {                                   The character constant ' \n I ,
                                                     awi tch statement c- ' S' .                                                      where n is up to four octal
    default: putchar('S')                           The default case is taken                                                         digits, yields a character with
                                                    since none of the case labels                                                     the octal value n. For instance,
                                                     match'S'. S is printed.                                                          \ 0 yields the ASCII character
                                                                                                                                      nul, and \ 101 the character
    continue                                        The continue statement                                                            A.
                                                     forces the next iteration of
                                                     the innermost enclosing loop,   ca8e 1:                                          Case labels may be either
                                                     in this case, the for loop.                                                      character or integer constants.
                                                     Notice that continue is                                                          \ 1 matches the integer 1 since
                                                     effectively a branch to the                                                     C automatically coerces char
                                                     reinitialization expression of                                                  to into
                                                     the for.                        while( (c-input[++il)I_'\1' &&cl.'\O')          The exit condition for the
    for(; (c-input[3)1.'\0'; i++) {                  c gets the fourth character                                                     while is either c._'\ l ' or
                                                     from input.                                                                     end of string. Each time the
                                                                                                                                     while test is made, i is
     8witch( 'W') {                                  c .... 'W'.
                                                                                                                                     incremented by 1, thus, the
     default: putchar( 'W'); continue                As before, Wis printed.                                                         loop advances i past the
                                                                                                                                    characters of input to either
                                                     Similarly for 1-4, c-'I'.
                                                                                                                                     the next ' \ 1 ' character or the
     8witch( 'L') {                                   i=S, c-'L'.                                                                    end of string.
                                                     The ' L' case is taken;         In the while loop:
     case ' L' : continue
                                                      nothing is printed.             i-12, c='\11';                                Nothing is printed.
     In the for loop:                                                                 i.13,c='W';                                   Nothing is printed.
       i-S,C-'L';                                     Nothing is printed.             i-14,c-'\1';                                  The while loop terminates.
       i-6, c-''1'';                                  '1' printed.                  case 9: putchar ( , S' )                        The statements from each case
       i-7, c-'E';                                    Nothing is printed.                                                           follow one another directly;
                                                                                                                                    there is no implied break
       i-a,c-'c';                                     C is printed.                                                                 between cases. Case 9 foUows
       i-9, c.'H';                                     H is printed.                                                                case 1. S is printed.
                                                       i-10, c-' 1'.                ca8e ' E': ca8e ' L': continue                  Cases ' E I and       L' follow case
      8witch('1') {                                                                                                                                     I
                                                                                                                                    9.
116 SWITCH, B.u. AK, AND CONTINUE STATEMENTS
                                                                                                                                    CHOOSE THE RIGHT CONDITION 117
   forI ; (c=input[ 15]); i++) {             Again, back to the top of the Programming Style 1.1
                                             for loop.
   In the for loop:
     i .. 15. c='W';                         W is printed.                   The need for a continue statement can often be eliminated by altering a test condition.
                                                                             The resulting code is sometimes remarkably cleaner.
     i=16. c='A';                            A is printed.
     i-17. c='L';                            Nothing is printed.             For this problem, simply negating the test to the if statement will do.
     i=1S. c='L';                            Nothing is printed.                   while(A)
                                                                                           H(IB) C;
     i=19. c='M';                            M is printed.
     i=20. c='P';                            P is printed.
     i- 21. c=' 1 ' ;                        Space is printed.
                                                                           Programming Style 1.2
     i-22. c='\O';                           The for loop terminates.
   putchar ( , \n' )
                                                                             The do ..• whi leis     another of the C constructs that can sometimes be replaced to
                                                                             advantage. If either a   do .•• whi 1 e or a whi 1 e can be used, the whi leis always
                                                                             preferred since it has  the desirable property that the condition is tested before every
                                                                             iteration of the loop.  That the condition is not tested before the first iteration of a
                                                                             do .•. whi 1 e loop has been the source of many a program bug.
                                                                             In this problem, the if and do .•• whi 1 e are redundant; they are effecting a whi le.
                                                                                  do (                           First, eliminate the continue.
                                                                                          if(A)    { B; C;    }
                                                                                   } while (A) ;
                                                                                  while(A) {                     Then replace the do ••• while and if with a while.
                                                                                          B; C;
liS CHOOSE The RIGHT CONDITION                                                                                                                       CHOOSE THE RIGHT CONSTRUCT 119
Programming Style 1.3                                                                        Programming Style 2.1
   The problem of deeply nested if stat~ments is well.. known to mos~ experi~~ced                    done = i • 0;                                             The first observation is that the
   programmers: by the time one gets to the mnermost condition the surrounding .c~nditioDa           while( i<MAXI && Idone ) {                                if ••• continue construct is
   have been forgotten or obscured. The counter approach is to qualify each condition fully,                if( (x/-2) > 1 ) i++;                              effecting an if ••• else. So
   but this tends to generate long conditions that are obscure from the start. Alas, good                   else done++;                                       make it an if ••• else!
                                                                                                     }
   judgement must prevail!
   Here are two possibilities for this problem:                                                      i • 0;                                                   Then it becomes clear that
                                                                                                     while( i<MAXI && (x/.2»1 ) i++;
                                                                                                                                                                 • one loop condition is done
             if( A && B && C ) D;                                                                                                                                  equal to FALSE;
             else if( IA && B && C ) E;
                                                                                                                                                                 • done is FALSE as long as
             else if( IA && B && IC ) F;                                                                                                                           the if condition is TRUE;
                                                                                                                                                                • thus, one loop condition is
    or,                                                                                                                                                             (x/2) > 1.
                                                                                                                                                              Make it explicit!
             if( B )
                     if( A && C ) D;
                     else if( IA && C ) E;                                                           fore i=O; i<MAXI && (x/.2»1; i++                         A while statement that is
                     else if( IA && IC ) F;                                                                                                                   preceded by an initialization
                                                                                                                                                              and that contains a change of
                                                                                                                                                              the loop control variable is
                                                                                                                                                              exactly a for statement.
 Programming Style 1.4
    This problem has a straightforward idea hierarchy:
                                                                                             Programming Style 2.2
          • while there are more characters on the line
          • multi way switch based on character type
                   • return ALPHA                                                              There are usually many ways to express an idea in C. A useful guideline is to group ideas
                   • return DIGIT                                                              into chunks. C provides a hierarchy of packaging for these chunks:
                   • return OTHER.                                                                   • the lowest level ideas become expressions;
     This translates easily into C:                                                                  • expressions are grouped together into statements;
                                                                                                     • statements are grouped together into blocks and functions.
              while( (e-getehar(»            I- '\n' ) {
                      if( e>.'a' && e<.'z' ) return(ALPHA);                                    In this problem there is a two level idea hierarchy. At the lowest level are the expressions
                      else if( e>-'O' && e<-'9' ) return(DIGIT);
                                                                                               B, D, F, and G. They are related as the mutually exclusive cases of a multiway switch. A
                      else if( el-'" && el.'\t' ) return(OTHER);
                                                                                               cohesive representation for a general multiway switch is the if .•• else if construction.
              }
              return(EOL);                                                                             if (A) B;
                                                                                                       else if(C) D;
                                                                                                       else if(E) F;
                                                                                                       else G;
                                                                                                       return;
~o CHOOSE THE RIGHT CONSTRUCT                                                                                                        CHOOSE THE RIGHT CONSTRUCT 121
                                                                                             Programming Style 2.4
rogramming Style 2.3
                                                                                                  i = 0;                                              Reformatting the
                                                                                                  while( (c=getchar(»I=EOF && cl="n' ) {              statements to indicate
  The key observation in this problem is that the underlying structure is a three-way switch            iff clz"n' && cl=',t' ) {                      nesting is a good start.
  with mutually exclusive cases.                                                                             8[i++] = c;                              Then look closer at the
                                                                                                             continue;                                break and
                                                                                                        }
         plusflg = zeroflg = negflg = 0;                                                                                                              continue statements
                                                                                                        iff c=="t' ) c   =, '.
                                                                                                                              •                       to see if they are really
         if( a>O ) ++plusflg;                                                                           s[i++] = c;                                   necessary. The break
         else if( a==O ) ++zeroflg;                                                                                                                   goes easily by adding
         else ++negflg;                                                                                                                               the negation of the
                                                                                                                                                      break condition to the
                                                                                                                                                     condition for the .
                                                                                                                                                      while.
                                                                                                 i  = 0;                                             The first if condition
                                                                                                 while( (c=getchar(»I=EOF && cl="n' ) {              can then be reduced.
                                                                                                       iff cl="t' ) {                                (c I = ' 'n' is now a
                                                                                                             s[i++] = c;                             loop condition, hence it
                                                                                                             continue;                               must always be TRUE
                                                                                                       }
                                                                                                                                                     in the if test.)
                                                                                                       iff c=="t' ) s[i++] = , ' .
                                                                                                                                 •
                                                                                                 i = 0;                                             The continue
                                                                                                 while( (c=getchar(»I=EOF && cl="n'                 statement is effecting
                                                                                                       iff cl="t' ) s[i++] = c;                     an if ... else.
                                                                                                       else s[i++] = ' ';
                                                                                                 fore i=O; (c=getchar(» I=EOF && cl="n'; i++        Finally, it is clear that
                                                                                                       iff cl="t' ) s[i] = c;                       s [ i] gets the next
                                                                                                       else s[i] = ' ';                             character if the
                                                                                                                                                    character is not a tab,
                                                                                             or,                                                    otherwise it gets a
                                                                                                                                                    space. In other words,
                                                                                                 fore i=O; (c=getchar(» I=EOF && cl="n'; i++        the code merely
                                                                                                       s[i] z cl="t' ? c : ' ';                    replaces tabs by spaces.
                                                                                                                                                   The last two versions
                                                                                                                                                   show this quite clearly
                                                                                                                                                   while also pointing out
                                                                                                                                                   the close relationship of
                                                                                                                                                   the if to the
                                                                                                                                                   conditional. In this
                                                                                                                                                   example, the if
                                                                                                                                                   emphasizes the test for
                                                                                                                                                   tab and the conditional
                                                                                                                                                   emphasizes the
                                                                                                                                                   assillnml!'!nt tn .. r; 1
122 CHOOSE THe KIGHT CONSTRUCT                                                                                                                                                BLOCKS 123
Programming Style 2.5                                                           Storage Classes 1.1
                                                                                     int i-O;                     i.O - 0
                                                                                                                  (The notation x.n is used to reference the variable x defined at
                                             In this problem it is quite clear
    if( j>k ) y = j I (xl=O ? x : NEARZERO);                                                                      block level n.l) The storage class of i.O is extern. 2 The scope of
    else y • k I (xl-O ? x : NEARZERO);      that x I '" 0 is not the primary
                                                                                                                  i.O is potentially any program loaded with this file. The lifetime
                                             idea; the test simply protects
                                                                                                                  of 1.0 is the full execution time of this program.
                                             against division by zero. The
                                             conditional nicely subordinates        main( )
                                             the zero check.                         {                            Block level is now 1.
                                                                                     auto int i-1;                i.l - 1 (i at level 1).
    y • MAX(j.k) I    (xl-O ? x NEARZERO) ;   A case can be made that the                                         The storage class of i.l is auto. The scope of i.l is the function
                                             assignment to y is the primary                                       main. 'The lifetime of i.l is the duration of the execution of
                                              idea, subordinating both tesu.                                      main.
                                              (MAX returns the greater of ill '
                                                                                     PRINT 1 ( d. i.l ) ;         When two variables have the same name, the innermost variable is
                                              two arguments.)
                                                                                                                  referenced when the name is given; the outer variable is not
                                                                                                                  directly accessible.
                                                                                     {                            Block level is now 2.
                                                                                     int i=2;                     i.2'" 2.
                                                                                                                  The storage class of i.2 is auto, the default storage class for
                                                                                                                  variables defined in block 1 or deeper. The scope of i.2 is block 2
                                                                                                                  and its lifetime is the duration of execution of block 2.
                                                                                     PRINT 1 ( d • i.2) ;
                                                                                                                  Block level is now 3.
                                                                                                                  i.2 - 3.
                                                                                     PRINT 1 ( d • i.2) ;         i.2 is printed since it is the innermost variable named i.
                                                                                     }                            Block level returns to 2.
                                                                                     PRINT 1 ( d • 1.2) ;         i.2 is printed again.
                                                                                                                  Block level returns to I; i.2 dies.
                                                                                     PRINT 1 (d. 1.1) ;           With the death of 1.2, i.l became the innermost variable named
                                                                                                                  i.
                                                                                     }                            Block level returns to O.
                                                                                I. ne   block level at any point in the text of a program is the count of left braces ({) minus the count of
                                                                                   riaht braces (}). In other words, it is the number of textually open blocks. The outermost level of a
                                                                                   propam, i.e., no blocks open, is block level O.
                                                                                1 You might ask why the storage class of i is not explicitly declared here using the extern keyword.
                                                                                   Unless declared otherwise, the storage class for variables defined at block level 0 is extern. Tagging
                                                                                   a variable with extern does not define the variable. Instead, it tells the compiler that the variable
                                                                                   has been defined elsewhere at block level O.
                                                                                                                                                           MORE FUNCTIONS 125
124 FUNCTIONS
Storage Classes 2.1                                                                               Storage Classes 3.1
   int i=LOW;                            1.0  == O.
   main( )                                                                                               int i=l;                       1.0 =   1.
   {                                                                                                     main( )
   auto int i=HIGH;                      i.l   == 5.
   reset(i.1I2) ;                        The function reset is called with the value i.1/2, or
                                                                                                         auto int i,j;                  i.l and j.l are defined, but not yet set.
                                         2. Its execution has no effect on i.1.
                                                                                                         1.1 = reset();                 i.l gets the value returned by reset.
   PRINT1 (d, 1.1);
                                                                                                            reset ( )
    reset( 1.l=i.1/2);                   reset is again called with i.1/2. This time i.l is
                                         assigned 2 as a side effect of the function call. Again,
                                         reset has no effect on i.1.                                        return ( 1.0) ;            As reset has neither a parameter nor a
    PRINT1(d,i.l);                                                                                                                     local variable named i, the reference to i
                                                                                                                                       must refer to 1.0. reset returns 1, so
    i.l =reset (1.112) ;                  i.l gets the value returned by reset called with
                                                                                                                                       1.1 = 1.
                                          i.1/2. We will expand the function call in line.
                                                                                                            }
        int reset ( 1)                   The type of the value returned by a function is
                                          specified in its declaration. reset returns a value of         fort j.l=l; j.l<3; j.l++ ) {   j.l    1.
                                          type into                                                      PRINT2(d,1.I, j.l);
        { (int i=l;)                       i.reset == 1.                                                 PRINT 1 (d, next (1.1) ) ;
                                          Parameters in a function behave like initialized local
                                          variables. We indicate these implied assignments by               int next( 1)
                                          surrounding them with parentheses.                                { (int j=l;)               j.next  = 1.
        i.reset = i.reset<=2? 5       2;   i.reset == 5.                                                    return( j.next=i.O++);     i.O = 2 but next returns 1 since the
        return( 1.reset) ;                 reset returns the integer 5; thus, i.l    == 5.                                            increment occurs after the value of i.O is
                                                                                                                                      taken.
         }
     PRINT1(d,1.l)                                                                                                                    The return statement references i.O
                                                                                                                                      since next knows of no other i. j.next
     workover ( i.l ) ;                    workover is passed the value of 1.1; 1.1 is not
                                                                                                                                      dies with the return.
                                           affected by the call. We'll expand workover since it
                                           includes a PRINT.                                                }
         workover(5)                       If not otherwise specified, functions return an into         PRINT1 (d,last( i.l);
          { (int i=5;)                      1.workover = 5.                                                  int last ( 1 )
          i.workover = 0   * whatever;      i.workover   == O.                                               { (int j=1;)              j.last = 1.
         PRINT 1 ( d , 1. workover) ;                                                                        static int i=10;          i.last = 10.
                                            workover returns 0, but the value is ignored in the                                       last has a local variable named i
          return( i.workover) ;                                                                                                       initialized to 10. The storage class of i is
                                            calling routine.
                                                                                                                                      static, which means that i is initialized
           }                                                                                                                          when the program is loaded and dies when
                                                                                                                                      the program is terminated.
      PRINT1 (d, i.l) ;
126 MOREFU       IONS                                                                                                                                                        LES 121
          return ( j.last= i.last- - ) ;   i.last = 9 but 10 is returned since the         Storage Classes 4.1
                                           decrement occurs after the value is taken.
                                                                                               int i=1;                       i.O  =  1.
                                           j.last dies with the return. but i.last lives
                                           on. Thus. when last is called again.                main ( )
                                           i.last will be 9.
          }                                                                                    auto int i, j ;
      PRINT1 (d,new( i.l+j.l»;                                                                 i.l = reset();
          int new( 2)                                                                             extern int i;               The extern statement tells the compiler that i is an
          { (int i-2;)                      i.new == 2.                                                                       external variable defined elsewhere. possibly in
                                                                                                                              another file. Here i refers to La.
          intj=10;                          j.new"" 10.
                                                                                                  reset( )
            return( i.new= j.new+=i.new) ;  j.new .. 12. i.new .... 12. and 12 is
                                                                                                  {
                                           returned.
                                            j.newand i.new die with the return.                   return ( La) ;              i.O is the external i referenced in reset.
           }                                                                                                                  ~.1 == 1.
      forI j.l=1; j.l<3; j.l++ ) {           j.l ... 2.
                                            Back to the f or statement. For this               forI j.l=1; j.l<3; j.l++){     j.l     1.
                                            iteration we will generalize about the effcc:l
                                            of each statement.                                 PRINT2 (d, i.l , j.l ) ;
                                                                                               PRINT 1 ( d, next ( i.l ) ) ;
                                                                                                  static int i-10;           The second source file begins with an external
       PRINT2 ( d , i.l , j.l ) ;           The effect of executing the loop body is to                                      definition of a variable named i. This definition
                                            increment j.l by one. The loop has no                                            might appear to be in conflict with the external
                                            effect on the value of i.1.                                                      variable i defined in the first file. The designation
       PRINT1 (d, next (i.l) ) ;             next ignores the value it is passed and                                          static, however, tells the compiler that this i is
                                             returns the current value of i.O. As a side                                     ~nown only within the current file. In other words, it
                                             effect of executing next. i.O is                                                IS only known within the functions next, last, and
                                             incremented by one.                                                             new. We will reference it by i.nln; i.nln - 10.
                                             last also ignores the value of its passed            next( )
       PRINT1 (d,last( Ll»;
                                             argument. It returns the current value of                                       The declaration of next does not include any
                                             its local static variable. i.1ast. As a                                         arguments. The value passed by main is ignored.
                                             side effect of executing last. i.last is
                                             decremented by one.                                  return( i.nln+=1) ;        i.nln - 11 and next returns 11.
                                              new returns the value of its argument pllll         }
       PRINT1 (d,new( i.l+j.l»;
                                              10. There are no lasting side effects.           PRINT1 (d,last(i.l»;
        }                                                                                         last ( )
        }
                                                                                                  return ( Lnln - -1 ) ;     Lnln = 10 and last returns 10. last references
                                                                                                                             the same i previously incremented by next.
                                                                                                  }
128 FILfS                                                                                                                                SIMPLE POINTER AND,            .AY 129
       PRINT1 (d,new( i.I+j.I));                                                    Pointers and Arrays 1.1
          new(2)
          { (int i=2;)               i.new   == 2.                                          int a [] = {O, 1 ,2,3,4} ;   a is defined to be an array of five integers, with
          static int j=S;            j.new = 5.                                                                          elements a [ i ] = i for i from 0 to 4.
          return( i.new=j.new=S+2) ; j.new = 7, i.new =      7, and 7 is returned.          fore i=O; i<=4; i++ )        i takes on the values 0 to 4.
                                     i.nln is unaffected, i.new will die with the           PR ( d , a [ i ] ) ;         a [ i] successively accesses each element of a.
                                     return, and j.new will be 7 when new is called
                                     again.
                                                                                    Pointers and Arrays 1.2
       fore j.I=1; j.I<3; j.l++ ) {   j.l == 2.
                                     In this iteration we will generalize about the
                                     effect of each statement.
                                                                                           int *p;                       Declarations of the form type *x tell the compiler
                                                                                                                        that when *x appears in an expression it yields a
                                                                                                                        value of type type. x is a pointer-to-type taking on
       PRINT2 (d, i.I, j.I);         The effect of the loop is to increment j.I by
                                                                                                                        values that are addresses of elements of type type.
                                     one.                                                                               Type is the base type of x. In this problem, p is
       PRINT1 (d,next( i.I));        next increments i.nln and returns the                                              declared as a pointer-to-integer; the base type of p
                                     resulting value.                                                                   is into
       PRINT1 (d ,last( i.I) );       last decrements i.nln and returns the                for ( p= &.a [ 0 ] ;         &.a [ 0] evaluates to the address of a [ 0 ] .
                                     resulting value.                                      p<=&.a[4];                   Array elements are stored in index order, that is,
       PRINT1 (d,new( i.l+j.I));     new adds its argument to j.new and returns                                         a [ 0] precedes a [ 1 ] precedes a [ 2] and so on.
                                     the resulting sum.                                                                 Thus p, initialized to &.a [ 0 ]. is less than &.a [ 4 ].
        }                                                                                  PR(d,*p) ;                   *p evaluates to the integer stored at the address
                                                                                                                       contained in p. Since p holds &.a [0], *p is
        }                                                                                                               a[ 0].
                                                                                           p++ )                       When applied to a pointer variable, the increment
                                                                                                                       operator advances the pointer to the next element
                                                                                                                       of its base type. What actually happens is that the
                                                                                                                       pointer is incremented by sizeof (base type)
                                                                                                                       bytes. C does not test to insure that the reSUlting
                                                                                                                       address is really that of a valid element of the base
                                                                                                                       type. In this problem, p is advanced to the next
                                                                                                                       element of a.
                                                                                          p<=&.a[4]                    p is again tested against the end of the array. The
                                                                                                                       loop is terminated when p points beyond the last
                                                                                                                       element of a. While in the loop, p points
                                                                                                                       successively to each element of a in index order.
130 SIMPLE POL,..,R AND ARRAY                                                                                                                          SIMPLE POINTER AND ARRAY 131
Pointers and Arrays 1.3                                                                              Pointers and Arrays 1.5
        fore p-&a[0],i .. 1; i< .. 5; i++              p points to the start of the array a. i takes         fore p=a+4;                  p points to the fifth element of a.
                                                       on the values 1 through 5.
                                                                                                             p >= a;                     The loop terminates when p points below a.
        PR(d,p[i]);                                    p [ i] successively refers to the elements of
                                                       a. p [ 5] points outside of the array.                                            The integer pointed to by p is printed.
                                                                                                             p--                         p is decremented to the preceding element.
   About arrays and indices. Though by far the most common use of [ ] is to represent array
   subscripting. [] actually is a general indexing operator. x [ i] is defined to be * (x+ i).
   wbere x is usually an address and i is usually integral. The rules of address arithmetic
                                                                                                     Pointers and Arrays 1.6
   apply, so i is in units of sizeof (base type of x). (It should by now be clear why array
   indices begin at O. An array name is actually a pointer to the first element in the array. An
   index is the offset from the array start. The offset to the first element from the array start is
   0.) In this last problem. i is used to index offp. p[i]'" *(p+i)'" *(a+i)'" a[i].                         fort p=a+4, i-O; i<-4; i~+  p points to the last element of a, i goes from
   i goes from 1 to 5. Wben i-5, p+i points just beyond the end of the array, hence the                                                  o to 4.
   value at p+i is unknown. This is such a common mistake, it is worth noting again: all                    PR(d,p[-i]);
   array with n eiemenlS has indices 0/ 0 through n - 1.                                                                                 The element - i away from the last element of
                                                                                                                                         a is printed.
Pointers and Anays 1.4                                                                               Pointers and Arrays 1.7
        for(p=a,i=O;                                   p gets the address of the first element of a.        fore p=a+4; p>-a; p-- )     p points successively to the elements of a from
        p+i <- a+4;                                    p=a, i=O, so p+i"'a+O. which is less                                             the last to the first.
                                                      than a+4.                                             PR(d,a[p-a]);               p-a evaluates to the offset from the start of
        PR(d,*(p+i»;                                   *(p+i) ... *(a+O) - a[O].                                                        the array to the clement pointed to by p. In
                                                                                                                                        other words. p-a is the index of the clement
        p++, i++ )                                     p points to the second element of a, i is                                        pointed to by p.
                                                       1.
        p+i <- a+4                                     p-a+1, i-1. thus p+i-a+2.
        PR(d,*(p+i»;                                   * ( p+ i) - a [ 21.
        p++, i++                                       p-a+2, i-2.
        p+i <- a+4                                     p+i"'" a+4.
        PR(d,*(p+i»;                                   *(p+i) - a[41.
        p++, i++                                       p-a+3, i-3.
        p+i <- a+4                                     p+i - a+6, and the loop terminates.
                      ITERS                                                                                                                                ARRAY OF       ___ ITERS 133
132 ARRAYOF
                                                                                                   Pointers and Arrays 2.2
Pointers and Arrays 2.1
                                                                                                         PRINT2(d,a,*a);         As noted earlier, the name of an array is
       int a[] .. {O,1,2,3,4}                            a is initialized to be an array of five                                 synonymous with the address of the first element in
                                                         integers.                                                               the array. The value of a is thus the address of the
                                                         When encountered in an expression,                                      array a, and *a is equivalent to a [0].
       int *p[] = {a,a+1,a+2,a+3,a+4};
                                                         *p [ ] evaluates to an integer, thus .          PRINT3(d,p,*p,**p);     p evaluates to the address of the first element of
                                                         p[ ] must point to an integer, and PIS                                  the array p, *p yields the value of the first
                                                         an array of pointer-to-integer. The five                                element, i.e., p [0], and **p yields the integer at
                                                         elements of p initially point to the five                               the address contained in p [0], i.e., the value at
                                                         elements of a.                                                          a [01.
        int **pp .. p;                                    **pp evaluates to an integer, hence            PRINT3(d,pp,*pp,**pp);  pp yields the contents of pp, which is the address
                                                          *pp must point to an integer, and pp                                   of p. *pp yields the value at p, or p[ 0]. And
                                                          must point to a pointer-to-intege r . pp                               **pp yields the integer pointed to by p[ 0], or
                                                         initially points to p [ 0 ].                                            a[ 0 1.
   Figure 2.1 illustrates the relationships between pp, p, and a.                                  Pointers and A"ays 2.3
                                                                                                         pp++                    pp is a pointer to pointer-to-integer (the base type
                                                                                                                                 of pp is pointer-to-integer), so pp++ increments
                                                                                                                                 pp to point to the next pointer in memory. The
                                  pp                                                                                             effect of pp++ is indicated by the bold arrow in
                                                                                                                                 Figure 2.3-1.
                                                                                                        pp-p                     pp points to the second element of the array p,
                                     p                                                                                           p[ 11. The value of pp is thus p+ 1.
                                                                                                                                pp-p = (p+ 1) -po which is 1.
                                                                                                        *pp-a
                                     a                                                                                          pp points to p[ 1] and *pp points to the second
                                                                                                                                element of the array a. The value of *pp is thus
                                                                                                                                a+1. *pp-a= (a+1)-a.
                                                                                                        **pp                    * pp points to a [ 1 ], so * * pp yields the contents
                                              Figure 2.1                                                                        at a [ 1].
                                                                                                        *PP++                   *(PP++)
                                                                                                                                Unary operators group from right to left. First the
                                                                                                                                increment is bound, then the indirection. The bold
                                                                                                                                arrow in Figure 2.3-2 shows the effect of the
                                                                                                                                increment.
                                                                                                                                *(++pp)
                                                                                                                                (Figure 2.3-3)
                                                                                                        ++*pp                   ++(*pp)
                                                                                                                                (Figure 2.3-4)
134 ARRAY OF Pv,!'lTERS                                                                        ARRAY OF POIN .."RS 135
                                          Pointers and A"ays 2.4
    pp                   pp
                          p                 pp                                 pp
      p
                          a                    p                                p
      a
                                               a                                a
            Figure 2.3-1     Figure 2.3-2
                                                 Figure 2.4-1 pp=p                Figure 2.4-2  * ( * (pp+ + ) )
    pp                   pp
                                            pp                                 pp
      p                   p
                                               p                                p
      a                    a
                                               a                                a
            Figure 2.3-3     Figure 2.3-4
                                                 Figure 2.4-3 * ( + + ( *pp) )    Figure 2.4-4 ++ ( * ( *pp) )
                     :IONAL ARRAY                                                                                                                                        MULTIDIMENSIONAL.            AY 137
136 MULTIDI~
Pointers and Arrays 3.1                                                                                   Pointers and Arrays 3.2
                                                                                                                 for(i=O; i<3; i++)                i goes from 0 to 2 in the loop.
                                                a is a 3 by 3 matrix with rows 123,456, and 789.
        int a[3][3] = {                         a [ i ] [ j ] evaluates to an integer at offset j from           a[i][2-i]                         a [ i ] [ 2 - i] selects the diagonal from a [ 0 ] [ 2] to
            { 1,2,3 } ,                         the start of row i. a [ i] yields the address of the                                               a[2][0].
             { 4,5,6 } ,                        first element of row i. And a yields the address of                                                a [ i) yields the address of the first element of the
             { 7,8,9 }                          the first row of the matrix a. Thus a is a pointer to                                              ith row in the matrix a. *a [i) yields the value of
        };                                      three-element-integer-array, and a [ ] is a pointer-                                               the first element of the ith row.
                                                to-integer.
                                                                                                                                                   a + i yields the address of the ith row of a. * ( a + i )
                                                 *pa [ ] evaluates to an integer, thus pa [ ] is a                                                 yields the address of the first element from the ith
        int *pa[3] = {                          pointer-to-integer and pa is an array of pointer-to-                                             # row. * (a+ i) + i yields the address of the ith .
            a[O],a[1],a[2]                      integer. pa [ 0] is initialized to the first element of                                            element from the ith row. And * ( * (a+ i) + i) gets
        };                                      the first row of a, pa [ 1 ] to the first element in tM                                            the integer value from the ith element of the ith
                                                second row, and pa [ 2] to the first element in the                                                row.
                                                third row.
                                                 p is a pointer-to-integer initially pointing to the lint
        int *p = a[O];                           element of the first row of the matrix a.                Pointers and Arrays 3.3
                                                                                                                 for(i=O; i<3; i++)                i goes from 0 to 2 in the loop.
                                                                                                                 pa[i]                             pa [i ] accesses the ith element of pa. *pa [i)
Figure 3.1 illustrates the relationships between a, pa, and p.
                                                                                                                                                   accesses the integer pointed to by the ith element of
                                                                                                                                                   pa.
                                                                                                                 p[i]                              p points to the first element of the first row in the
                                                                                                                                                   matrix a. Since the base type of p is int, p[ i]
                                                                                                                                                   yields the ith element of the first row in a.
                                                                                                            About QlTay addresses. We have noted several times that the address of an array and the
                                                                                                            address of the first element in the array have the same value. In this past puzzle, we saw
                       pa[O]                                       1 2 3                                    that a and a [0] evaluated to the same address. One difference between the address of an
                                                                                                            array and the address of the first element in the array is the type of the address and, hence,
                       pa[1]                                       4 5 6                                    the unit of arithmetic on an expression containing the address. Thus, since the type of a is
                                                                   7 8 9                                    pointer to three-element-integer-array, the base type of a is three-element-integer-array and
                       pa[2]                                                                                 a+ 1 refers to the next three-element-integer-array in memory. Since the type of a [ 0] is
                                                                                                            pointer-to-integer, the base type of a [0] is integer and a [ 0 ] of" 1 refers to the next integer
                                                                                                            in memory.
                                              Figure 3.1
138 POINTER S1                                                                                                                                                                   POINTE)       EW 139
Pointers and Arrays 4. J                                                                             Pointers and Arrays 4.2
        char .c£] • {                        .c£ ] evaluates to a character, so c [ ] points to                                                     Increment cpp then follow the pointers.
             "ENTER",                        characters and c is an array of pointer-to-character.                                                  (Figure 4.2-1)
             "NEW",                          The elements of c have been initialized to point to the
             "POINT",                        character arrays "ENTER". "NEW". "POINT". and                                                          Increment CPP. follow the pointer to cp [ 2 ].
             "PIRST"                          "PIRST" .                                                                                             decrement cp [ 2 ]. follow the pointer to c [ 0 ).
                                                                                                                                                    index 3 from the address in c [0]. (Figure
                                                                                                                                                    4.2-2)
                                                                                                                                                    Indirectly reference - 2 from cpp yielding
        char •• cp[] • {                     •• cp[] evaluates to a character •• cp[] is a pointer-                                                 cp [ 0 ]. follow the pointer to c [ 3 ]; index 3
             c+3,c+2,c+1,c                   to-character. and cp [ ] is a pointer-to-pointer-to-                                                   from the address in c [31. (Figure 4.2-3}
        } ;                                  character. Thus cp is an array of pointers to pointer-
                                             to-character. The elements of cp have been initialized                                                 Indirectly reference -1 from cpp yielding
                                             to point to the elements of c.                                                                         cp [ 1 ]. indirectly reference - 1 from cp [ 1 ]
                                                                                                                                                    yielding c [ 1 ]. index 1 from the address in
        char ••• cpp • CPt                    ***cpp evaluates to a character. **cpp points to a                                                    c£ 11. (Figure 4.2-4)
                                             character•• cpp points to a pointer-to-character. and
                                             cpp points to a pointer-to-pointer-to-character.
                                                                                                       About pointers. If you can work this puzzle correctly then you know everything you will ever
Pilure 4.1 illustrates the relationships between CPP. cpo and c.                                       need to about the mechanics of using pointers. The power of pointers lies in their
                                                                                                       generality: we can chain them together to form an endless variety of complex data
                                                                                                       structures. The danger of pointers lies in their power: complex pointer chains are seldom
                                  cpp                                                                  readable and even more seldom reliable.
                                   cp
                                     c
                                           N       E        0
                                           T      W         I      R
                                           E       &       N        S
                                           R               T       T
                                           &                &      &
                                             Figure 4.1
140 POINTER S
                                                                                                        SIMPLE STRUcrURE. NESTED SU             'URE 141
Pointers and Arrays 2.4                              Structures 1.1
   cpp
                                                              atatic atruct 51 {                                      The structure tag 5 1 refers to a
                                                                  char c[ 4], *a;                                     structure containing a character
                                                              } al = { "abc", "def" };                                array, c, of length 4, and a
                                                                                                                      character pointer, a. The
     cp                                                                                                               structure variable a 1 is an instanc
                                                                                                                      of the structure 5 1 initialized to
                                                                                                                               char c[4]-"abc",
                                                                                                                                          *a-"def"
       c
                                                                                                                     The structure has been defined as
                                                                                                                      atatic so that it may be
                                                                                                                     initialized in the definition.
            E       N      P F
                                                              atatic atruct 52 {                                     The structure tag 52 refers to a
            N       E      0 I                     I             char *cp;                                           structure containing a character
            T       W      I R            W      I R             atruct 51 aal;                                      pointer, cp, and an instance of tht
                                                                a2 • { "ghi", { "jkl", "mno" } };                    structure 51, a a 1. The structure
            E       &      N S             &     N S
                                                                                                                     variable a 2 is an instance of the
            R              T T                   T T                                                                 structure 52 initialized to
            &              & &                   & &                                                                           char *cp="ghi";
                                                                                                                               atruct 51 aal-
              Figure 4.2-1          Figure 4.2-2                                                                                   { n j k 1 .,   "mno·};
   Cpp                         Cpp                   Figure 1.1 depicts the structures a 1 and a 2.
      cp                        cp                                                81
                                                                          C
                                                                          8
        c                        c
             E
             N       E                                                            82
                                                                        Cp
                                                                                       Ijl ~I
             T       W     I
             E       &     N                                         881          C
                                                                                                    1   1  &1
            R
             &
                           T
                           &
                                   R
                                   &
                                                 T
                                                 &
                                                   T
                                                   &
                                                                                 8                             =:::::::::
              Figure 4.2-3          Figure 4.2-4
                                                                                                 J;"~RII.A 1 1
142 SIMPLE STR     'DRE, NESTED STRUCTURE                                                                                          SIMPLE STRUCTURE, NESTED STRt            JRE 143
Structures 1.2                                                                                Structures 1.3
        PRJ:NT2(c.          A character is to be printed.                                            PRINT2(8.     A string is printed.
        (81.C)[0]           Reference the first character of the e field of the structure 81.        81.e          Reference the string pointed to by the e field of the structure
                            (Figure 1.2-1)                                                                         s 1. Recall that c = &.0[ 0 1. (Figure 1.3-1)
                            Reference the character pointed to by the    8 field of the              81.8          Reference the string pointed to by the s field of the structure
                            structure 81. (Figure 1.2-2)                                                           81. (Figure 1.3-2)
                          s1                                                                                     s1
                   c                                                                                           c
                   s                                                                                           s
                                      Figure 1.2-1                                                                           Figure 1.3-1
                          s1
                                                                                                                 s1
                   c
                                                                                                               c
                   s
                                                                                                               s
                                      Figure 1.2-2                                                                          Figure 1.3-2
144 SIMPLE STJ   TURE, NESTED STRUCTURE                                                                                                     ARRAY OF STRU(           lFS 145
Structures 1.4                                                        Structures 2.1
                                                                                                                             S 1 is declared to be a tag referring to a
                                                                               struct S 1 {
                                                                                                                            structure containing a character pointer, s, an
                                                                                  char *s;                                  integer, i, and a pointer to structure of type
                cp                                                                int ii                                    S 1, s 1p. This is only a declaration; an
                                                                                  struct S1 *s1pi
               ss1                                                            };
                                                                                                                           instance of S 1 is not created.
                                  Figure 1.4-1 s2. cp                                                                      a is a three-element array with elements of
                                                                              static struct S1 a[] =                       type structure S 1. a has been defined as
                                                                                  { "abcd", 1, a+1.},                      s ta tic so that it can be initialized in the
                                                                                  { "efgh", 2, a+2 },                     definition.
                                                                                  { "ijkl", 3, a }
                                                                              }i
                c p '--_...---,..---.,---,---;
               ss1
                                                                                                                          p is a pointer to structures of type S 1. P is
                        s                                                    struct S1 *p=ai                              initialized to point to the first element of a.
                             Figure 1.4-2 (s2. ss 1) • s
                                                                     rl&ure 2.1 depicts the array a and the pointer p.
Structures 1.5
                                                                                                                        a
                        s2                                                      pi      •                        s
                 Cp                                        Iglhlil&1                                             i
               ss1      c       j                                                                             s1p
                        s                                  Imlnlol&1                              CaC     1] s
                              Figure 1.5-1 ++(s2.cp)
                                                                                                                 i
                                                                                                              s1p
                                                                                                  Car 2]        s
                        s2
                 cp L----r"--'T'----,r-:-'T"":':--1
               ss1
                        s                                                                                      Figure 2.1
                          Figure 1.5-2 + + ( ( s 2 • s s 1) • 8 )
146 ARRAY OF STRUCTURES                                                                                              ARRAYOFSTRUCTURES 147
Structures 2.2
        PRINT3(s.             Strings are to be printed.
        (a[O]).s              Reference the string pointed to by the s field of the                             a
                              structure that is the first element of a. (Figure 2.2-1)  pi •
                              Reference the string pointed to by the s field of the                       j
        p->s
                              structure pointed to by p. (Figure 2.2-2)
                                                                                                                   1
                                                                                                     s1p
        «(a[2]).s1p)-»s       Reference the string pointed to by the s field of the
                              structure pointed to by the s 1p field of the structure
                              that is the third element of a. (Figure 2.2-3)
                                                                                             C  a [1] s
                                                                                                         j        2
                                                                                                     s1p
                                                                                             C a [2] s
                                                                                                        j         3
                                       a
                               s                                                                     s1p
                                i         1
                                                                                                       Figure 2.2-2
                                i
                                                                                                              a
                   C a [ 2 ] _S_~-=--+--_-l                                            pI •           s
                                                                                                      i          1
                                                                                                    s1p
                                                                                             C a[ 1] s
                                                                                                      j         2
                                Figure 2.2-1
                                                                                                     Figure 2.2-3
                                                                                                                   ARRAY OF S' __ cruRES 14
148 ARRAY 01 ~.RucrURF.S
Structures 2.3
        fore i=O; i<2; i++ ) {       i takes on the values of 0 and 1.
        PR(d,                        Print an integer.
        --( (a[i]) .i)               Decrement then reference the integer in the i
                                     field of the structure that is the ith element of                     a
                                     a. (Figure 2.3-1 shows the case for i=O)
                                     Print a character.
                                                                                       pi •           s
        PR(e,
                                     Increment then reference the fourth character
                                                                                                       i         0
        ++«(a[i).s)[3)
                                     of the string pointed to by the s field of the                 s1p
                                     structure that is the ith element of a. (Figure
                                     2.3-2 shows the case for i=O)                          C~[ 1]    s
                                                                                                      i         :2
                                                                                                   s1p
                                                                                            Ca[2]     s
                                        a                                                             i
          pIL-_ •_-~~--4--a
                 •          [0] S          ..
                                           0
                                                                                                   s1p
                                                                                                                3
                                 i
                                s1p f-e
                               ] s         ....                                                    Figure 2.3-2
                                 i         2
                                s1p f-e
                               ] s
                                 i          3
                                s1p r---e
                                 Figure 2.3-1
ISO ARRAY OF     UCfURES
                                                                                                                              ARRAY OFSTRUcrURES lSI
Structures 2.4
        ++(p->s)                    Increment the s field of the structure pointed                                       a
                                   to by p, then output the string pointed to by
                                   the s field. (Figure 2.4-1)
                                                                                      P --_...J
       4[«++p)->i)].s               First p is incremented, then the s field of the
                                                                                                                    i       o
                                    p->ith structure of 4 is accessed. (Figure
                                    2.4-2)
       4[--(fp->s1p)->i)].s         The i field of the structure pointed to by the
                                    s 1 p field of the structure pointed to by p is                                         1
                                    decremented then used as an index into 4.
                                    (Figure 2.4-3)
                                                                                                                  i       3
                                                                                                             s1p
                                      a
         pi .........--a[Ol    s                                                                               Figure 2.4-2
                               i         o
                               i                                                                                      a
                                                                                    p
                             s1p
                      ~a[21-s--l------""~I i I j Ikill s I                                                      i        o
                               i                                                                ,..,y.--S       1p
                             s1p                                                                   a [ 1-:0"]-s-+-~-:!_[ elf Ig I i I s]
                                                                                                               i
                              Figure 2.4-1
                                                                                                              i
                                                                                                           s1p
                                                                                                            Figure 2.4-3
152 ARRAY OL __ INTERS TO STRUcrURFS
                                                                                                                                                      ARRAY OF POINTERS TO STRUcrURFS 153
Structures 3.1                                                                                         Structures 3.2
        struct 51 {                               5 1 is declared to be a tag referring to a
                                                  structure containing a character pointer, s, and            for ( i =0; i < 3; i + + )
             char *s;                                                                                                                                     i takes on the values 0, 1, 2.
             struct 51 *s1p;                     a pointer to structure of type 5 1, s 1p.                    p[i] = (aCi]).s1p;
                                                                                                                                                          The i~h ele.ment of p gets a copy of
         } ;
                                                                                                                                                         the pOInter In the s 1p field of the ith
                                                                                                                                                         element of a. (Figure 3.2-1)
                                                                                                              (p[O])->s, (*p)->s, (**p).s
        static struet 51 a[]            ={        a is a three-element array with elements of                                                            T~ese are all ways of saying the same
             { "abed", a+1 },                     type structure 5 1. a has been defined as                                                              thIng. (Figure 3.2-2)
             { "efqh", &+2 },                     static so that it can be initialized in the
             { "ijkl", & }                        definition.
         } ;
                                                                                                                p
                                                  When encountered in a program statement, ..                                                        a
         struct 51 *(p[3]);
                                                   expression * ( p [ ] ) yields a structure 51.      pC 0]                                  s
                                                  Thus, p [ 1 points to a ~tructure 51, and pill      pC 1 ] 1 - - _ - . . 1
                                                   three-element array of pointers to structura fII                                        s1p
                                                   type 51.                                           pC 2]                                  s
                                                                                                                                          s1p
 Fagurc 3.1 depicts the arrays a and p.
                                                                                                                                             s
                                                                                                                                          s1p
                p                                       a                                                                                 Figure 3.2-1
                                  a[O]                                     lalblcldl&1
             §
  p[O]                                       s
  p[1]                                    s1p                                                                 p                                    a
  p[2]                                       s                                                      :,[0 ]
                                                                                                                                           s
                                           s1p                                                       p[ 1 ]                              s1p
                                             s                                                      ,[2 ]                                  s
                                           s1p                                                                                           s1p
                                                                                                                                           s
                                           Figure 3.1                                                                                    s1p
                                                                                                                                         Figure 3.2-2
154 ARRAY Of            "ITERS TO STRUcrURES
                                                                                                                                                       ARRAY OF POINTERS TO STRUC J uRES 155
Structures 3.3
                                                        p points to p [ 0 ], so * p yields the content of
                                                        p [ 0] or 5.a [ 1 J. a yields 5.a [ 0 J.
         temp • (5.a [ 1 ] ) - > 8    ;                 Equivalently, temp - a [ 1 ) • s.
         ( 5.a [ 1 ) ) - > 8 = (5.a [ 0 ] ) - > 8       Or, a ( 11. s -=   at 0 1. s
         ( 5.a [ 0 ) ) - > s • temp                     swap swaps the strings pointed to by the     8
                                                        fields of its arguments. (Figure 3.3-1)                       p                                 a
        (p[O])->s. (*p)->s                              (Figure 3.3-2)                                      p[ 0]
                                                                                                                                                s
        «*p)->s1p)->s                                   (Figure 3.3-3)                                      p [ 1 ] t-----t
                                                                                                                                ;-o~--s1p
                                                                                                                                             ---t---~
                                                                                                          , p[ 2]                               S
                                                                                                                                ,-r---s1p
                                                                                                                                    [2]      -s---t-~~t--_liljlklll&1
                                                                                                                                 ~--s1p
            p                                                a
pro]                                                 s                            I a\ hi C\ d\ &]
p[ 1]                                              s1p                                                                                      Figure 3.3-2
p[2]                                                 s
                                                   s1p
                                                     s
                                                   s1p
                                                                                                                    p                                a
                                                                                                           prO]                               s
                                                  Figure 3.3-1                                            ,pC 1 ] r----;=~t__I d k " - - - S  1p
                                                                                                                                                                     lalblc/dlsl
                                                                                                          ,pC 2]                           -s.-.,-.-~
                                                                                                                  -----'
                                                                                                                               ,.---s1p
                                                                                                                                           --;------1
                                                                                                                                             S
                                                                                                                                ~--s1p
                                                                                                                                          --""'------'
                                                                                                                                          Figure 3.3-3
156 ARRAY Of          ~TERS     TO STRUCTURES
                                                                                                                                                            ARRAY OF POINTERS TO STRUCl   is 157
Structures 3.4
        swap ( p [ 0 ], (p [ 0 ] ) - > S 1 p) ;            p [ 0] contains &.a [ 1 ]. (p [ 0 ] ) - > S 1 P
                                                          contains &.a [ 2 1. (Figure 3.4-1)
                                                                                                                          p                                  a
                                                                                                                prO]    I---~
                                                                                                                                                        s
                                                                                                                p[ 1 ]            ~~--s 1p
           p                                                    a                                               p[2]~;=j~~~                         --s~~-~
p[O]                                                 S                                                                                                                        le/f/glhisl
         1----1                                                                                                                    ~:-II---          s 1P
p[1]                        .Pt.---- S               1P                                                                                             --=-I---~
p[2]
         1----1
         1...--_.....1
                                                --=-1------1
                                                     S
                                                                                                                                      ---s1p
                                                                                                                                                        s                     /i/jlkI1Isl
                          ......,iJ.....--s1p                                                                                                       --=-L--_....J
                                                -~I----i
                                                     s
                                                                                                                                       Figure 3.4-3 (* (++ (p[ 0] ) ) ) . s
                              ---s1                  p __
                                                _....:........L        .....I
                                                Figure 3.4-1
                                                                                                                        p                                  a
                                                                                                           . , p[ 0]
                                                                                                                                                      s
                                                                                                               p [ 1 ] 1-----1
                                                                                                                                 ~---s1p
                                                                                                                                                                            [a I b I c Id I SJ
                                                                                                                                                  -    __1--_-1
           p                                                    a                                          . p[ 2]
p[O]
         J----I
                                                     S
                                                                                     ~~~~~~                            ~-~
                                                                                                                                 ~-.---s1p
                                                                                                                                                      s
                                                                                                                                                                            [ elf Ig I h I SJ
p[1]                         AfIr.---            S   1p                                                                                           --1----1
         1----1                                 -~--.....,                                                                                           s
p[2]                                                 s
         '-------'                                                                                                              -----s1p
                             ...-lr---s1p
                                                -....::......,1------1
                                                     s
                              ---s1p
                                                --'-------'                                                                    Figure 3.4-4 ++( (*(H( (*P)->s1p») .s)
                                         Figure 3.4-2 (p( 0] ) ->s
158 THE PREP       :FSSOR DOESN'T KNOW C                                                                                                               THE PREPROCFSSOR DOESN'T Kl            r C 159
Preprocessor 1,1                                                                                       Preprocessor 1.2
       int x=2;
       PRINT( x*FUDGE(2) );                                  To understand the effect of a
                                                             preprocessor macro, expand it in place. .       for(cel=O; cel<-100; cel+=50)
                                                                                                                     PRINT2( cel,9./5*cel+32 );
      PR(a); putchar('\n')                                   Always expand the leftmost macro.
                                                             First, substitute the macro replacclllCll
                                                             string for the macro call.
       PRe x*FUDGE(2)        ); putchar('\n')                                                               for(cel=O; cel<-100; cel+=50)                            First expand the call to PRINT2.
                                                             Then substitute the argument(s) in Ik,
                                                                                                                    PRe cel);
                                                             call for those in the replacement striIJ.
                                                                                                            PRINT( 9./5*cel+32 );
                                                             Expand the leftmost macro, PR tm
                                                             time.
      printf(" x*FUDGE(2) • %d\t",                           Substitute the macro arguments.
             (int)(x*FUDGE(2»)                                                                              for(cel=O; cel<-100; cel+=50)                            Then expand the call to PR.
                                                                                                                    printf(" cel- %d\t",(int)(cel»;
      printf(" x*FUDGE(2) • %d\tft,                          A macro name that occurs between               PRINT( 9./5*cel+32 );
             (int)(x*k+3.1459»                               quotes is not expanded. However,
                                                             macro arguments are expanded
                                                             wherever they occur in the macro ~
                                                             Thus, x*FUDGE ( 2) replaces a in.·'            for(cel=O; cel<=100; cel+=50)                            Expand the call to PRINT.
                                                             macro PR, but FUDGE ( 2) is left                       printf(" cel- %d\t",(int)(cel»;
                                                             unexpanded in the format of the cal.           PRe 9./5*cel+32 ); putchar('\n');
                                                             printf.
       (int)(x*2+3.14159)                                    Replace the formal parameter k by.,
                                                             actual parameter. Surprise! First
                                                             multiply, then add (then truncate),            for (cel=O; cel<= 100; cel+=50)                          Expand the call to PR.
                                                                                                                    printf(" cel- %d\t",(int)(cel»;
                                                                                                           printf(" 9./5*cel+32 =%d\t",
                                                                                                                     (int)(9./5*cel+32»;
   Beware! Macros can be a source of subtle trickery. Expanding a macro is strictly a matter
                                                                                                           putchar( '\n');
   of replacing one string by another. The macro preprocessor knows next to nothing about C.
   Most surprises can be avoided by adhering to a few conventions.
   Convention 1: Parenthesize all macro bodies that contain operatOf's.
   The unwanted interaction between the replacement string and its context in this problem.             The call to PRINT2 may look like a single statement, but it expands to three, Only the first
   avoided if FUDGE (k) is defined to be (k+3. 14159).                                                   PR is contained within the for loop. The second PR is executed following the loop, with
                                                                                                         cel=150.
                                                                                                        Convention 2: Keep macro bodies cohesive; prefer an expression to a statement, a single
                                                                                                        SlGlement to mulliple statements.
                                                                                                        For this problem, using commas in place of the semicolons in the body of the PRINT
                                                                                                        macros satisfies Convention 2.
  160 THE PREPR(        SOR DOFSN'T KNOW C
I
                                                                                                                                                                                  CAUTI(      AYS 161
  Prept'ocessor 1.3                                                                                  Preprocessor 2.1
          int x= 1, y=2;
                                                                                                             intx=1;
          PRINT3( MAX(X++,y) ,x,y );
                                                                                                             PRINT ( -NEG (x) );
          (a<b ? b : a) ,x,y                         The PRINT3 macro is, of course, expanded
                                                     before MAX. However, to avoid obscuring                 --a
                                                                                                                                                     First substitute the macro replacement string
                                                     the point of the puzzles, in this and                                                           for the macro call. (As before, the PRINT
                                                     following solutions the PRINT macros will                                                       macro will not be expanded.)
                                                     not be expanded. The first step then is to              --x, and x=o
                                                     substitute the replacement string for the call                                                  Then substitute the argument in the call for the
                                                                                                                                                     one in the replacement string.
                                                     to MAX.
          (x++<y? y : x++) ,x,y                      Next, substitute the actual arguments for
                                                     the formal arguments.                             T:e macro replace~ent string ~s e~ctly. those characters that foUow the closing parenthesis
          (1<2?y: x++), andx-2                       Finally, evaluate.                                o the ar~ume?t hst. ~he trIck In. thiS puzzle is that the -a immediately foUows the
                                                                                                       parenthesIs. Stl~l, follo':"lDg Convention 1 by defining NEG ( a) to be (_ a) produces the
          (y)
                                                                                                       expected expansIOn. It IS also a good practice to begin each replacement string with either a
          2                                                                                           tab or a space.
          PRINT3( MAX(x++,y) ,x,y );                 Now execute the second call to PRINT3.
                                                                                                    Preprocessor 2.2
          (x++<y ? y : x++) ,x,y
          (2<2? y: x++), andx=3
          (x++)                                                                                            PRINT( weeks( 10080)
          3, and x=4                                                                                        (days( 10080)/7)
                                                                                                                                                    Rep.lace each macro call with the macro body.
                                                                                                                                                    Notice that there is not a conflict between the
                                                                                                                                                    macro parameter mins and the macro mins.
    x++ appears only once in the macro call but twice in the expansion, causing x to be                     «hours(10080)/24)/7)
    incremented sometimes by one and sometimes by two. The burden of protecting against                     «(10080/60)/24)/7)
    such unfortunate side effects can be placed either with the macro writer or the macro user.
                                                                                                                                                    Evaluate.
    Convention 3: Avoid /?UlCl'O bodies that can cause obscure or inconsistent side effects.
    Convention 3A: Avoid expressions with side effects in macro ca/Is.
                                                                                                           PRINT( days(mins(86400»
    In general, the problem of side effects in macros is quite tricky. Following Convention}
    often means copying arguments into local variables within the macro; this extra overhead               (hours(mins(86400»/24)                  Expand the leftmost macro.
    reduces the speed advantage of macro calls over function calls. Following Convention 3A                «mins(86400)/60)/24)
    requires knowing when a routine has been coded as a macro rather than a function; at best,
    this violates the notion of the routine as an abstraction, and at worst, the routine may be            «(86400/60)160)124)
    rewritten causing the assumption no longer to be valid.                                                                                        Evaluate.
     For this problem following Convention 3A preserves MAX intact.
162 CAUTI4        AYS
~eprocessor     2.3
        static char input. "\twhich\if?";
        if(c<' ') TAB(c,i,oldi,temp);
        else putchar(c);
        if(c<' '}
                 if(c·.'\t'}
                          for(temp.8-(i-oldi-1)~8,oldizi;                  temp; temp--}
                                  putchar(' '};
                 else putchar(c};
   TAB includes an open if statement. On expansion, the if consumes the following else.
   Convention 4: Malee macro replacement strings complete C entities, be they expressions,
   statements (minus the c/osing semicolon), or blocks.                                         APPENDICES
   For this problem, appending a null else clause to the TAB macro alleviates the difficulty.
   (Notice that enclosing the macro replacement string in braces, i.e., making it a block, does
   not solve the problem.)
   About macros and functions. Very often a routine can be implemented using either a macro
   or a function. The advantage of using a macro is that it will be executed faster since the
   runtime overhead of a function call is avoided. The advantages of using a function are that
   none of the tricky situations we've seen in the puzzles with macros will occur, and if the
   routine is called several times, the implementation will probably require less memory. This
   leads us to the final convention for using macros:
   Convention 5: Keep macros simple.    If you can't keep a macro simple, make it afunction.
                        APPE1'.1.I.X 1: Precedence Table
                                OPERATOR                        ASSOCIATIVITY
                primary: ( ) [ ] - > .                              left to right
                unary: 1 - ++ -- - (type ) * &. si~¢of              right to left
                multiplicative: */"                                 left to right
                additive: + -                                       left to right
                shift: « »                                          left to right
                relational: < <= > >=                               left to right
                equality: == 1=                                     left to right    .
                bitwise: &.                                         left to right
                bitwise:  A
                                                                    left to right
                bitwise: II                                         left to right
                logical: &.&                                        left to right
                logical: II II                                      left to right
                conditional: ? :                                    right to left
                assignment: = += -= etc.                            right to left
                comma: •                                            left to right
The precedence table illustrates the relative precedence of operators. Precedence determines
the order in which operands are bound to operators. Operators receive their operands in order
of decreasing operator precedence.
To determine the relative precedence of two operators in an expression find the operators in the
OPERATOR column of the table. The operator higher in the list has the higher precedence. If
the two operators are on the same line in the list, then look at the corresponding
ASSOCIATIVITY entry. If it indicates "left to right", then the operator to the left in the
expression has the higher precedence; if it indicates "right to left", then vice versa.
                                               165
                       APPENDIX 2: Operator Summary Table
     Arithmetic operators (operands are numbers and pointers)
      • Additive
                    o erator                            °elds                     restrictions
                      x+y                  sum of x and y               if either operand is a
                                                                        pointer the other must
                                                                        be integralt
                      x-y                  difference of x less y       if either operand is a
                                                                        pointer the other must
                                                                        be integral or a pointer
                                                                        of the same base type
      • Multiplicative
                    o erator                            °elds                     restrictions
                      x*y                  product of x and y            x, y must not be
                                                                        pointer
                      x/y                  quotient of x divided        x, y must not be
                                           by y                         pointer
                      x"y                  remainder of dividing x      x, y must not be
                                           by y                         double, 6oat, or pointer
                       -x                  arithmetic negation of       x, y must not be
                                           x                            pointer
      • Incremental
                    o erator                            ields                     restrictions
                  x++ (x--)                x                            x must be a reference
                                           x is incremented             to a numeric value or a
                                           (decremented) after          pointer
                                           use
                  ++x (--x)                x+ 1 (x-1)                   x must be a reference
                                           x is incremented             to a numeric value or a
                                           (decremented) before         pointer
                                           use
i,
I
I    t Integral stands for the types int, char, short, long. and unsignedo
j
 t
1
 1
 \..                                                  167
168 OPERATOR SUMMARY TABLE                                                                                                                    OPERATOR SUMMARY TABLE 169
Assignment operators                                                                Logical operators (operands are numbers and pointers)
           o erator                        ields                    restrictions                 o erator                          ields                      restrictions
                             Y cast in the type of x,     x, y may be any type                    x&&y             AND of x and y: 1 if             result is of type int
                             x gets the value of y        but array                                                both x and yare
                                                                                                                   nonzero, 0 otherwise
           xop= y            x op (y) cast in the         x, y may be any type
                             type of x, x gets the        but array or structure                  xlly             inclusive OR of x and            result is of type int
                             value of x op (y)                                                                     y: 0 if both x and y
                                                                                                                   are zero, 1 otherwise
                                                                                                    Ix             logical negation of x: 0         result is of type int
Bitwise operators (operands are integral)                                                                          if x is nonzero, 1
                                                                                                                   otherwise
 • Logical
             orator                          "elds                    restrictions
              x&y              bit by bit AND of x and
                               y; AND yields a 1 for
                               each place both x and
                                                                                       Comparison (operands are numbers and pointers)
                               y have a 1, 0                                            • Relational
                               otherwise
                                                                                                  o erator                           ields                      restrictions
               xly             bit by bit inclusive OR
                               of x and y; inclusive                                             x<y (x>y)            1 if x is less than             result is of type int
                               OR yields a 0 for each                                                                (greater than) y, 0
                               place both x and y                                                                    otherwise
                               have a 0, 1 otherwise                                           x<=y (x>=y)            1 if x is less than or          result is of type int
               xAy             bit by bit exclusive OR                                                               equal to (greater than
                               of x and y; exclusive                                                                 or equal to) y, 0
                               OR yields a 0 for each
                                                                                                                     otherwise
                               place x and y have the
                               same value, 1                                           • Equality
                               otherwise
                                                                                                  o erator                           ields                      restrictions
                -x              one's-complement of                                            x==y (x I =y)          1 if x is equal to (not         result is of type int
                                x; 1s become Os and                                                                  equal to) y, 0
                                Os 1s                                                                                otherwise
  • Shift                                                                               • Conditional
             o erator                         ields                    restrictions                                                                             restrictions
                                                                                                  o erator                           ields
              x«y               x left shifted y places,    y must be positive and                 x?y:z             y if x is nonzero,    Z
                                the lowest y bits get Os    less than the number of                                  otherwise
                                                            bits per computer word
              x»y               x right shifted y places;    y must be positive and
                                the highest y bits get      less than the number of
                                Os for positive x, 1s or     bits per computer word
                                Os depending on the
) OPERATOR SUMMARY TABLE
                                                                                                                 APPENDIX 3: ASCII Table
Idress operators
                                                                                     In octal
        o erator                    'elds                restrictions
                                                                                         1000   nuliOO 1   sohl002    stxl003    etxl004     eotl005   enql006    aekl007   bell
            IIX       the value at the address x must be a pointer
                                                                                         1010   bs 1011    ht 1012    nl 1013    vt 1014     np 1015   er 1016    so 1017   si I
                      contained in x cast in                                             1020   dlel021    de11022    de21023    de31024     de41025   nakl026    synl027   etb
                      the base type of x                                                 1030   eanl031    em 1032    subl033    esel034     fs 1035   9S 1036    rs 1037   us
                                               x must be a reference                     1040   sp 1041                            # 1044     S 1045         1046   &. 1047
           &.x        the address of x
                                               to a value                                1050
                                                                                         1060
                                                                                                  ( 1051
                                                                                                  o 1061
                                                                                                             I 1042
                                                                                                             ) 1052
                                                                                                             1 1062
                                                                                                                        " 1043
                                                                                                                        II 1053
                                                                                                                        2 1063
                                                                                                                                   + 1054
                                                                                                                                   3 1064
                                                                                                                                               , 1055
                                                                                                                                              4 1065
                                                                                                                                                         "
                                                                                                                                                         - 1056
                                                                                                                                                         5 1066
                                                                                                                                                                    • 1057
                                                                                                                                                                    6 1067
                                                                                                                                                                              I
                                                                                                                                                                              7
          xCy]        the value at the address one of the operands
                                                                                         /070    8 /071     9 1072         /073       1074    < 1075     = 1076     > 1077    ?
                      x+y cast in the base     must be an address and                                                                         D 1105     E 1106     F 1107    G
                                                                                         1100    @l 1101    A 1102      B 1103     C 1104
                      type of the address      the other must be                                                                   K 1114     L 1115     M 1116     N 1117    0
                                                                                         1110    H 1111     I 1112      J 1113
                      operand                  integral                                           p 1121                R 1123     S 1124     or 1125    U 1126     V 1127    W
                                                                                         1120               Q 1122
           x.y        the value of the y field x must be a structure,                    1130    X 1131     y 1132'     Z 1133     [ 1134     \ 1135     ] 1136     A  1137
                      of the structure x       y a structure field                       1140     ' 1141    a 1142      b 1143     e 1144     d 1145     e 1146     f 1147     9
                                                                                         1150    h 1151     i 1152      j 1153     k 1154     I 1155     m 1156     n 1157     0
          x->y        the value of the y field x must be pointer to a                            p 1161     q /162                                                  v 1167     w
                                                                                         1160                           r /163     s /164     t /165     u /166
                      of the structure at the  structure, y a structure                                     y 1172                 { 1174        1175    } 1176             dell
                                                                                         1170    x 1171                 z 1173                                       - 1177
                      address x                field
                                                                                     In hexadecimal
                                                                                           00   null   01  sohl   02  stxl   03  etxl    04  eotl  05  enql    06 aekl   07 bell
'pe operators                                                                              08   bs I   09  ht I   Oa  nl I   Ob  vt I    Oe  np 1  Od  er I    Oe so I   Of  si I
                                                                                           10   dlel   11  de11   12  de21    13 de31    14  de4/  15  nak     16 syn/   17 etbl
             rator                  ields                restrictions
        0                                                                                  18   ean    19  em I   1a  subl    1b esel    1e  fs I  1d  9S      1e rs I   1£ us I
         (type) x      x cast in the type type  x may be any                               20   sp     21    I I  22    " I  23         24    s I  25          26   &. I 27     • I
                                               expression                                  28
                                                                                           30
                                                                                                  (
                                                                                                  0
                                                                                                       29
                                                                                                       31
                                                                                                             ) I 2a
                                                                                                             1 I 32
                                                                                                                        II I
                                                                                                                        2 1
                                                                                                                             2b
                                                                                                                             33
                                                                                                                                   #1
                                                                                                                                   + I
                                                                                                                                   3 I
                                                                                                                                        2e
                                                                                                                                         34
                                                                                                                                              , I
                                                                                                                                              4 I
                                                                                                                                                   2d
                                                                                                                                                   35
                                                                                                                                                         "
                                                                                                                                                         5
                                                                                                                                                               2e
                                                                                                                                                               36   6 I
                                                                                                                                                                       I 2f
                                                                                                                                                                         37
                                                                                                                                                                               /
                                                                                                                                                                               7 I
                                                                                                                                                                                  I
       sizeof x       the size in bytes of x    x may be any
                                                expression                                 38    8     39   9 I 3a         I 3b       1  3e   < 1  3d    II:   3e    > 1 3f    ? I
                                                                                           40    @l    41   A 1 42      BI   43    c 1  44    DI   45    E     46   F 1  47    G 1
     sizeof(type)     the size in bytes of an                                              48    H    49    I 1 4a      JI   4b    K I 4e     L I  4d    M     4e   NI   4f    0 /
                       object of type type                                                 50    p    51    Q I 52      RI   53    s 1 54     or I 55    U     56   V I  57    W I
                                                                                           58    X    59    yl 5a       Z 1  5b    [ I 5e     \  1 5d     ]    5e    A 1 5f       I
                                                                                           60         61    a I 62      b  I 63    e I 64     d  I 65    e     66    f I 67    9 I
                                                                                           68    h    69    i I 6a      j  I 6b    k I 6e     I  1 6d    m     6e   nl   6f    01
:quence operator                                                                           70    p    71    q I 72      r 1  73    s I 74     t  I 75    u     76   vi   77    wi
                                                                                           78    x    79    y I 7a      z I  7b    { / 7e        / 7d     }    7e    - I 7f  dell
        o erator                     ields                restrictions
           X,y         y                        x, y may be any
                       x is evaluated before y  expression
                                                                                     ASCII (American Standard Code for Information Interchange) maps a set of control an(
                                                                                     printable characters into a set of seven bit binary numbers. The tables above show tht
                                                                                     correspondence between each character and its value. Generally, the characters below 04l
                                                                                     octal (20 hexadecimal) are considered control characters and are not printable, though newline
                                                                        1\,r;)/~;~~J
                                                                                     tab, formfeed, etc. are located here. 040 and above are the familiar printing characters. Digit:
                                                                                     and letters are ordered in their natural way; 1 is before 2 and A is before B.
                                                                        /:"./: DtDI¢
                                                                         ~        !
                          APPENI.l!X 4: Type Hierarchy Chart
             double        ~    float
             long
                T
            unsigned
            int      ~    char, short
  The type hierarchy chart illustrates the ordering of the arithmetic types. The execution of each
  arithmetic operator in an expression yields a result with the type of its highest typed operand.
  Similarly, when two quantities are compared by a relational operator, the lower typed operand is
  cast in the type of the higher typed operand. The vertical arrows in the chart show the basic
  ordering: double is the highest type, int the lowest. The horizontal arrows indicate the
. aut~~~_!YI'C:~()I!Y~<:rsj()J!..s.,._.That is, operands of type f loa t are always converted to type
  double before being consid~.~ in an expressioJ!. Likewise. operands of types char and
  short are always converted to type into
